theory Logic
  imports Language
begin

subsection \<open>Hyper assertions\<close>

type_synonym 'a hyperassertion = "('a set \<Rightarrow> bool)"

definition entails where
  "entails A B \<longleftrightarrow> (\<forall>S. A S \<longrightarrow> B S)"

lemma entails_refl:
  "entails A A"
  by (simp add: entails_def)

lemma entailsI:
  assumes "\<And>S. A S \<Longrightarrow> B S"
  shows "entails A B"
  by (simp add: assms entails_def)

lemma entailsE:
  assumes "entails A B"
      and "A x"
    shows "B x"
  by (meson assms(1) assms(2) entails_def)

lemma bientails_equal:
  assumes "entails A B"
      and "entails B A"
    shows "A = B"
proof (rule ext)
  fix S show "A S = B S"
    by (meson assms(1) assms(2) entailsE)
qed

lemma entails_trans:
  assumes "entails A B"
      and "entails B C"
    shows "entails A C"
  by (metis assms(1) assms(2) entails_def)

definition setify_prop where
  "setify_prop b = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. b \<sigma>\<^sub>p}"

lemma sem_assume_setify:
  "sem (Assume b) S = S \<inter> setify_prop b" (is "?A = ?B")
proof -
  have "\<And>\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> ?A \<longleftrightarrow> (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> ?B"
  proof -
    fix \<sigma>\<^sub>l \<sigma>\<^sub>p l
    have "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> ?A \<longleftrightarrow> (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S \<and> b \<sigma>\<^sub>p"
      by (simp add: assume_sem)
    then show "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> ?A \<longleftrightarrow> (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> ?B"
      by (simp add: setify_prop_def)
  qed
  then show ?thesis
    by auto
qed

definition over_approx :: "'a set \<Rightarrow> 'a hyperassertion" where
  "over_approx P S \<longleftrightarrow> S \<subseteq> P"

definition lower_closed :: "'a hyperassertion \<Rightarrow> bool" where
  "lower_closed P \<longleftrightarrow> (\<forall>S S'. P S \<and> S' \<subseteq> S \<longrightarrow> P S')"

lemma over_approx_lower_closed:
  "lower_closed (over_approx P)"
  by (metis (full_types) lower_closed_def order_trans over_approx_def)

definition under_approx :: "'a set \<Rightarrow> 'a hyperassertion" where
  "under_approx P S \<longleftrightarrow> P \<subseteq> S"

definition upper_closed :: "'a hyperassertion \<Rightarrow> bool" where
  "upper_closed P \<longleftrightarrow> (\<forall>S S'. P S \<and> S \<subseteq> S' \<longrightarrow> P S')"

lemma under_approx_upper_closed:
  "upper_closed (under_approx P)"
  by (metis (no_types, lifting) order.trans under_approx_def upper_closed_def)

definition closed_by_union :: "'a hyperassertion \<Rightarrow> bool" where
  "closed_by_union P \<longleftrightarrow> (\<forall>S S'. P S \<and> P S' \<longrightarrow> P (S \<union> S'))"

lemma closed_by_unionI:
  assumes "\<And>a b. P a \<Longrightarrow> P b \<Longrightarrow> P (a \<union> b)"
  shows "closed_by_union P"
  by (simp add: assms closed_by_union_def)

lemma closed_by_union_over:
  "closed_by_union (over_approx P)"
  by (simp add: closed_by_union_def over_approx_def)

lemma closed_by_union_under:
  "closed_by_union (under_approx P)"
  by (simp add: closed_by_union_def sup.coboundedI1 under_approx_def)

definition conj where
  "conj P Q S \<longleftrightarrow> P S \<and> Q S"

lemma entail_conj:
  assumes "entails A B"
  shows "entails A (conj A B)"
  by (metis (full_types) assms conj_def entails_def)

lemma entail_conj_weaken:
  "entails (conj A B) A"
  by (simp add: conj_def entails_def)

definition disj where
  "disj P Q S \<longleftrightarrow> P S \<or> Q S"

definition exists :: "('c \<Rightarrow> 'a hyperassertion) \<Rightarrow> 'a hyperassertion" where
  "exists P S \<longleftrightarrow> (\<exists>x. P x S)"

definition forall :: "('c \<Rightarrow> 'a hyperassertion) \<Rightarrow> 'a hyperassertion" where
  "forall P S \<longleftrightarrow> (\<forall>x. P x S)"

lemma over_inter:
  "entails (over_approx (P \<inter> Q)) (conj (over_approx P) (over_approx Q))"
  by (simp add: conj_def entails_def over_approx_def)

lemma over_union:
  "entails (disj (over_approx P) (over_approx Q)) (over_approx (P \<union> Q))"
  by (metis disj_def entailsI le_supI1 le_supI2 over_approx_def)

lemma under_union:
  "entails (under_approx (P \<union> Q)) (disj (under_approx P) (under_approx Q))"
  by (simp add: disj_def entails_def under_approx_def)

lemma under_inter:
  "entails (conj (under_approx P) (under_approx Q)) (under_approx (P \<inter> Q))"
  by (simp add: conj_def entails_def le_infI1 under_approx_def)

text \<open>Operator \<open>\<otimes>\<close>\<close>
definition join :: "'a hyperassertion \<Rightarrow> 'a hyperassertion \<Rightarrow> 'a hyperassertion" where
  "join A B S \<longleftrightarrow> (\<exists>SA SB. A SA \<and> B SB \<and> S = SA \<union> SB)"

lemma joinI: 
  assumes "A S1"
      and "B S2"
    shows "(join A B) (S1 \<union> S2)"
  by (meson assms(1) assms(2) join_def)

definition general_join :: "('b \<Rightarrow> 'a hyperassertion) \<Rightarrow> 'a hyperassertion" where
  "general_join f S \<longleftrightarrow> (\<exists>F. S = (\<Union>x. F x) \<and> (\<forall>x. f x (F x)))"

primrec nat_join :: "nat \<Rightarrow> (nat \<Rightarrow> 'a hyperassertion) \<Rightarrow> 'a hyperassertion" where
  "nat_join 0 f = (\<lambda>S. False)"
| "nat_join (Suc n) f = join (nat_join n f) (f (Suc n))"

lemma general_joinI:
  assumes "S = (\<Union>x. F x)"
      and "\<And>x. f x (F x)"
    shows "general_join f S"
  using assms(1) assms(2) general_join_def by blast

lemma join_closed_by_union:
  assumes "closed_by_union Q"
  shows "join Q Q = Q"
proof
  fix S
  show "join Q Q S \<longleftrightarrow> Q S"
    by (metis assms closed_by_union_def join_def sup_idem)
qed

lemma entails_join_entails:
  assumes "entails A1 B1"
      and "entails A2 B2"
    shows "entails (join A1 A2) (join B1 B2)"
proof (rule entailsI)
  fix S assume "join A1 A2 S"
  then obtain S1 S2 where "A1 S1" "A2 S2" "S = S1 \<union> S2"
    by (metis join_def)
  then show "join B1 B2 S"
    by (metis assms(1) assms(2) entailsE join_def)
qed

text \<open>Operator \<open>\<Otimes>\<close> (for \<open>x \<in> X\<close>)\<close>
definition natural_partition where
  "natural_partition I S \<longleftrightarrow> (\<exists>F. S = (\<Union>n. F n) \<and> (\<forall>n. I n (F n)))"

lemma natural_partitionI:
  assumes "S = (\<Union>n. F n)"
      and "\<And>n. I n (F n)"
    shows "natural_partition I S"
  using assms(1) assms(2) natural_partition_def by blast

lemma natural_partitionE:
  assumes "natural_partition I S"
  obtains F where "S = (\<Union>n. F n)" "\<And>n. I n (F n)"
  by (meson assms natural_partition_def)

subsection \<open>Rules of the Logic\<close>

subsection \<open>Soundness\<close>

text \<open>Hyper-Triples\<close>

type_synonym ('lvar, 'lval)conf = "('lvar \<Rightarrow> 'lval) \<times> state \<times> trace"
type_synonym ('lvar, 'lval)assn = "('lvar, 'lval)conf set \<Rightarrow> bool"

definition hyper_hoare_triple ("\<Turnstile> {_} _ {_}" [51,0,0] 81) where
  "\<Turnstile> {P} C {Q} \<longleftrightarrow> (\<forall>S. P S \<longrightarrow> Q (sem C S))"

lemma hyper_hoare_tripleI:
  assumes "\<And>S. P S \<Longrightarrow> Q (sem C S)"
  shows "\<Turnstile> {P} C {Q}"
  by (simp add: assms hyper_hoare_triple_def)

lemma hyper_hoare_tripleE:
  assumes "\<Turnstile> {P} C {Q}"
      and "P S"
    shows "Q (sem C S)"
  using assms(1) assms(2) hyper_hoare_triple_def
  by metis

lemma consequence_rule:
  assumes "entails P P'"
      and "entails Q' Q"
      and "\<Turnstile> {P'} C {Q'}"
    shows "\<Turnstile> {P} C {Q}"
  by (metis (no_types, opaque_lifting) assms(1) assms(2) assms(3) entails_def hyper_hoare_triple_def)

lemma skip_rule:
  "\<Turnstile> {P} Skip {P}"
  by (simp add: hyper_hoare_triple_def sem_skip)

lemma assume_rule:
  "\<Turnstile> {(\<lambda>S. P (Set.filter (b \<circ> fst \<circ> snd) S)) } (Assume b) {P}"
proof (rule hyper_hoare_tripleI)
  fix S assume "P (Set.filter (b \<circ> fst \<circ> snd) S)"
  then show "P (sem (Assume b) S)"
    by (simp add: assume_sem)
qed

lemma seq_rule:
  assumes "\<Turnstile> {P} C1 {R}"
    and "\<Turnstile> {R} C2 {Q}"
    shows "\<Turnstile> {P} Seq C1 C2 {Q}"
  using assms(1) assms(2) hyper_hoare_triple_def sem_seq
  by metis

lemma if_rule:
  assumes "\<Turnstile> {P} C1 {Q1}"
      and "\<Turnstile> {P} C2 {Q2}"
    shows "\<Turnstile> {P} IChoice C1 C2 {join Q1 Q2}"
  by (metis (full_types) assms(1) assms(2) hyper_hoare_triple_def join_def sem_if)

lemma assign_rule:
  "\<Turnstile> {(\<lambda>S. P {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(x := e \<sigma>\<^sub>p), l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S }) } (Assign x e) {P}"
proof (rule hyper_hoare_tripleI)
  fix S assume "P {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(x := e \<sigma>\<^sub>p), l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S }"
  then show "P (sem (Assign x e) S)" using sem_assign
    by metis
qed

lemma assign_rule_sp:
  "\<Turnstile> {P} (Assign x e) {\<lambda>S. (\<exists>S0. P S0 \<and> S = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(x := e \<sigma>\<^sub>p), l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0})}"
proof (rule hyper_hoare_tripleI)
  fix S assume "P S"
  then show "\<exists>S0. P S0 \<and> sem (x ::= e) S = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(x := e \<sigma>\<^sub>p), l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0}"
    using sem_assign by metis
qed

lemma havoc_rule:
  "\<Turnstile> {(\<lambda>S. P {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(x := v), l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S})} (Havoc x) {P}"
proof (rule hyper_hoare_tripleI)
  fix S assume "P {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(x := v), l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S}"
  then show "P (sem (Havoc x) S)" using sem_havoc by metis
qed


lemma send_rule:
  "\<Turnstile> {(\<lambda>S. P ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [OutBlock ch (e \<sigma>\<^sub>p)]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union>
  {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [WaitBlk d (\<lambda>_. State \<sigma>\<^sub>p) ({ch}, {}), OutBlock ch (e \<sigma>\<^sub>p)]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d. (d::real) > 0 \<and> (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union>
  {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [WaitBlk \<infinity> (\<lambda>_. State \<sigma>\<^sub>p) ({ch}, {})]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S}))} (Cm (ch[!]e)) {P}"
proof (rule hyper_hoare_tripleI)
  fix S
  assume "P ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [OutBlock ch (e \<sigma>\<^sub>p)]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union>
  {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [WaitBlk d (\<lambda>_. State \<sigma>\<^sub>p) ({ch}, {}), OutBlock ch (e \<sigma>\<^sub>p)]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d. (d::real) > 0 \<and> (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union>
  {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [WaitBlk \<infinity> (\<lambda>_. State \<sigma>\<^sub>p) ({ch}, {})]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S})"
  then show "P (sem (Cm (ch[!]e)) S)"
    using sem_send by metis
qed

lemma recv_rule:
  "\<Turnstile> {(\<lambda>S. P ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p(var := v), l @ [InBlock ch v]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union>
  {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(var := v), l @ [WaitBlk d (\<lambda>_. State \<sigma>\<^sub>p) ({}, {ch}), InBlock ch v]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d v. (d::real) > 0 
  \<and> (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union>
  {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [WaitBlk \<infinity> (\<lambda>_. State \<sigma>\<^sub>p) ({}, {ch})]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S}))} (Cm (ch[?]var)) {P}"
proof(rule hyper_hoare_tripleI)
  fix S
  assume "P ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p(var := v), l @ [InBlock ch v]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union>
  {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(var := v), l @ [WaitBlk d (\<lambda>_. State \<sigma>\<^sub>p) ({}, {ch}), InBlock ch v]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d v. (d::real) > 0 
  \<and> (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union>
  {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [WaitBlk \<infinity> (\<lambda>_. State \<sigma>\<^sub>p) ({}, {ch})]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S})"
  then show "P (sem (Cm (ch[?]var)) S)"
    using sem_recv by metis
qed

text \<open>Loops\<close>

lemma indexed_invariant_then_power:
  assumes "\<And>n. hyper_hoare_triple (I n) C (I (Suc n))"
      and "I 0 S"
  shows "I n (iterate_sem n C S)"
  using assms
proof (induct n arbitrary: S)
next
  case (Suc n)
  then have "I n (iterate_sem n C S)"
    by blast
  then have "I (Suc n) (sem C (iterate_sem n C S))"
    using Suc.prems(1) hyper_hoare_tripleE by blast
  then show ?case
    by (simp add: Suc.hyps Suc.prems(1))
qed (auto)

lemma indexed_invariant_then_power_bounded:
  assumes "\<And>m. m < n \<Longrightarrow> hyper_hoare_triple (I m) C (I (Suc m))"
      and "I 0 S"
  shows "I n (iterate_sem n C S)"
  using assms
proof (induct n arbitrary: S)
next
  case (Suc n)
  then have "I n (iterate_sem n C S)"
    using less_Suc_eq by presburger
  then have "I (Suc n) (sem C (iterate_sem n C S))"
    using Suc.prems(1) hyper_hoare_tripleE by blast
  then show ?case
    by (simp add: Suc.hyps Suc.prems(1))
qed (auto)

lemma while_rule:
  assumes "\<And>n. hyper_hoare_triple (I n) C (I (Suc n))"
  shows "hyper_hoare_triple (I 0) (Rep C) (natural_partition I)"
proof (rule hyper_hoare_tripleI)
  fix S assume asm0: "I 0 S"
  show "natural_partition I (sem (Rep C) S)"
  proof (rule natural_partitionI)
    show "sem (Rep C) S = \<Union> (range (\<lambda>n. iterate_sem n C S))"
      by (simp add: sem_while)
    fix n show "I n (iterate_sem n C S)"
      by (simp add: asm0 assms indexed_invariant_then_power)
  qed
qed

lemma rule_exists:
  assumes "\<And>x. \<Turnstile> {P x} C {Q x}"
  shows "\<Turnstile> {exists P} C {exists Q}"
  by (metis assms exists_def hyper_hoare_triple_def)

text \<open>continous\<close>

lemma rule_cont:
  "\<Turnstile> {(\<lambda>S. P ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S \<and> \<not> b \<sigma>\<^sub>p} \<union> 
  {(\<sigma>\<^sub>l, p d, l @ [WaitBlk d (\<lambda>\<tau>. State (p \<tau>)) ({}, {})]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l p d. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S \<and> d > 0 \<and> 
  ODEsol ode p d \<and> (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (p t)) \<and> \<not>b (p d) \<and> p 0 = \<sigma>\<^sub>p}))} (Cont ode b) {P}"
proof(rule hyper_hoare_tripleI)
  fix S 
  assume "P ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S \<and> \<not> b \<sigma>\<^sub>p} \<union> 
  {(\<sigma>\<^sub>l, p d, l @ [WaitBlk d (\<lambda>\<tau>. State (p \<tau>)) ({}, {})]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l p d. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S \<and> d > 0 \<and> 
  ODEsol ode p d \<and> (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (p t)) \<and> \<not>b (p d) \<and> p 0 = \<sigma>\<^sub>p})"
  then show "P (sem (Cont ode b) S)"
    using sem_ode by metis
qed

lemma rule_cont_sp: 
  "\<Turnstile> {P} (Cont ode b) {join (\<lambda>S. \<exists>S0. P S0 \<and> S = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> \<not> b \<sigma>\<^sub>p})
  (\<lambda>S. \<exists>S0. P S0 \<and> S = {(\<sigma>\<^sub>l, p d, l @ [WaitBlk (ereal d) (\<lambda>\<tau>. State (p \<tau>)) ({}, {})]) |\<sigma>\<^sub>l l p d. 
  (\<sigma>\<^sub>l, p 0, l) \<in> S0 \<and> 0 < d \<and> ODEsol ode p d \<and> (\<forall>t. 0 \<le> t \<and> t < d \<longrightarrow> b (p t)) \<and> \<not> b (p d)})}"
proof(rule hyper_hoare_tripleI)
  fix S
  assume "P S"
  then have "join (\<lambda>S. \<exists>S0. P S0 \<and> S = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> \<not> b \<sigma>\<^sub>p})
  (\<lambda>S. \<exists>S0. P S0 \<and> S = {(\<sigma>\<^sub>l, p d, l @ [WaitBlk (ereal d) (\<lambda>\<tau>. State (p \<tau>)) ({}, {})]) |\<sigma>\<^sub>l l p d. 
  (\<sigma>\<^sub>l, p 0, l) \<in> S0 \<and> 0 < d \<and> ODEsol ode p d \<and> (\<forall>t. 0 \<le> t \<and> t < d \<longrightarrow> b (p t)) \<and> \<not> b (p d)})
  ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S \<and> \<not> b \<sigma>\<^sub>p} \<union>
  {(\<sigma>\<^sub>l, p d, l @ [WaitBlk (ereal d) (\<lambda>\<tau>. State (p \<tau>)) ({}, {})]) |\<sigma>\<^sub>l l p d. (\<sigma>\<^sub>l, p 0, l) \<in> S \<and> 0 < d 
  \<and> ODEsol ode p d \<and> (\<forall>t. 0 \<le> t \<and> t < d \<longrightarrow> b (p t)) \<and> \<not> b (p d)})" (is "join ?A ?B (?S1 \<union> ?S2)")
  proof-
    have "?A ?S1" "?B ?S2"
      using \<open>P S\<close> by auto
    then show "join ?A ?B (?S1 \<union> ?S2)"
      by (smt (verit, del_insts) join_def)
  qed
  then show "join (\<lambda>S. \<exists>S0. P S0 \<and> S = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> \<not> b \<sigma>\<^sub>p})
  (\<lambda>S. \<exists>S0. P S0 \<and> S = {(\<sigma>\<^sub>l, p d, l @ [WaitBlk (ereal d) (\<lambda>\<tau>. State (p \<tau>)) ({}, {})]) |\<sigma>\<^sub>l l p d. 
  (\<sigma>\<^sub>l, p 0, l) \<in> S0 \<and> 0 < d \<and> ODEsol ode p d \<and> (\<forall>t. 0 \<le> t \<and> t < d \<longrightarrow> b (p t)) \<and> \<not> b (p d)})
  (sem (Cont ode b) S)"
    by (metis (mono_tags, lifting) sem_ode)
qed


lemma rule_complete_int_Nil:
  assumes "\<Turnstile> {P} Interrupt ode b [] {Q}"
  shows "entails (exists (\<lambda>S0. \<lambda>S. P S0 \<and> (\<exists>S1 S2. S1 = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> \<not> b \<sigma>\<^sub>p} \<and>
  S2 = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p', l @ [WaitBlk d (\<lambda> \<tau>. State (sl \<tau>)) (rdy_of_echoice [])]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d sl \<sigma>\<^sub>p'. 
  (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> d > 0 \<and> ODEsol ode sl d \<and> (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (sl t)) \<and> \<not> b (sl d) 
  \<and> sl 0 = \<sigma>\<^sub>p \<and> sl d = \<sigma>\<^sub>p'} \<and> S = S1 \<union> S2))) Q" 
proof(rule entailsI)
  fix S
  assume "(exists (\<lambda>S0. \<lambda>S. P S0 \<and> (\<exists>S1 S2. S1 = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> \<not> b \<sigma>\<^sub>p} \<and>
  S2 = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p', l @ [WaitBlk d (\<lambda> \<tau>. State (sl \<tau>)) (rdy_of_echoice [])]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d sl \<sigma>\<^sub>p'. 
  (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> d > 0 \<and> ODEsol ode sl d \<and> (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (sl t)) \<and> \<not> b (sl d) 
  \<and> sl 0 = \<sigma>\<^sub>p \<and> sl d = \<sigma>\<^sub>p'} \<and> S = S1 \<union> S2))) S"
  then obtain S0 S1 S2 where assm0: "P S0" "S1 = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> \<not> b \<sigma>\<^sub>p}"
  "S2 = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p', l @ [WaitBlk d (\<lambda> \<tau>. State (sl \<tau>)) (rdy_of_echoice [])]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d sl \<sigma>\<^sub>p'. 
  (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> d > 0 \<and> ODEsol ode sl d \<and> (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (sl t)) 
  \<and> \<not> b (sl d) \<and> sl 0 = \<sigma>\<^sub>p \<and> sl d = \<sigma>\<^sub>p'}" "S = S1 \<union> S2"
    by (smt (verit, best) exists_def)
  from assm0(1) assms have "Q (sem (Interrupt ode b []) S0)"
    using hyper_hoare_tripleE by blast
  with assm0(2) assm0(3) have "Q (S1 \<union> S2)"
    using sem_init_Nil[of ode b S0] by auto
  with assm0(4) show "Q S"
    by auto
qed    

(*
lemma rule_comlete_int_send:
  assumes "\<Turnstile> {P} Interrupt ode b (cs @ [a]) {Q}"
      and "a = (ch[!]e, C)"
    shows "\<exists>Q' R. entails (join Q' R) Q \<and> \<Turnstile> {P} Interrupt ode b cs {R} \<and> 
    \<Turnstile> {exists (\<lambda>S0. \<lambda>S. P S0 \<and> (\<exists>S1 S2. S1 = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [OutBlock ch (e \<sigma>\<^sub>p)])|\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0} 
    \<and> S2 = {(\<sigma>\<^sub>l, sl d, l @ [WaitBlk d (\<lambda>\<tau>. State (sl \<tau>)) (rdy_of_echoice cs), OutBlock ch (e (sl d))]) 
    |\<sigma>\<^sub>l \<sigma>\<^sub>p l d sl. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> d > 0 \<and> ODEsol ode sl d \<and> sl 0 = \<sigma>\<^sub>p \<and> (\<forall>t. t \<ge> 0 \<and> t < d 
    \<longrightarrow> b (sl t))} \<and> S = S1 \<union> S2))} C {Q'}"
proof(induct cs)
  case Nil
  then show ?case sorry
next
  case (Cons a cs)
  then show ?case sorry
qed
  sorry
*)

inductive hoare :: "('lvar, 'lval) assn \<Rightarrow> proc \<Rightarrow> ('lvar, 'lval) assn \<Rightarrow> bool" ("\<turnstile> ({(1_)}/ (_)/ {(1_)})" 50) 
  and interrupt_hoare :: "('lvar, 'lval) assn \<Rightarrow> nat \<Rightarrow> ODE \<Rightarrow> fform \<Rightarrow> (comm \<times> proc) list \<Rightarrow> ('lvar, 'lval) assn \<Rightarrow> bool" where
  SkipH: "\<turnstile> {P} Skip {P}"                                               
| ConsH: "\<lbrakk>entails P P'; entails Q' Q; \<turnstile> {P'} C {Q'}\<rbrakk> \<Longrightarrow> \<turnstile> {P} C {Q}" 
| AssignH: "\<turnstile> {(\<lambda>S. P {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(x := e \<sigma>\<^sub>p), l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S })} (Assign x e) {P}" 
| HavocH: "\<turnstile> {(\<lambda>S. P {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(x := v), l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S})} (Havoc x) {P}"   
| SeqH: "\<lbrakk> \<turnstile> {P} C1 {R}; \<turnstile> {R} C2 {Q} \<rbrakk> \<Longrightarrow> \<turnstile> {P} C1; C2 {Q}"
| AssumeH: "\<turnstile> {(\<lambda>S. P (Set.filter (b \<circ> fst \<circ> snd) S)) } (Assume b) {P}"
| IChoiceH: "\<lbrakk>\<turnstile> {P} C1 {Q1}; \<turnstile> {P} C2 {Q2} \<rbrakk> \<Longrightarrow> \<turnstile> {P} IChoice C1 C2 {join Q1 Q2}"
| RepH: "\<lbrakk>\<And>n. \<turnstile> {I n} C {I (Suc n)} \<rbrakk> \<Longrightarrow> \<turnstile> {I 0} (Rep C) {natural_partition I}"
| SendH: "\<turnstile> {(\<lambda>S. P ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [OutBlock ch (e \<sigma>\<^sub>p)]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union>
  {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [WaitBlk d (\<lambda>_. State \<sigma>\<^sub>p) ({ch}, {}), OutBlock ch (e \<sigma>\<^sub>p)]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d. (d::real) > 0 \<and> (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union>
  {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [WaitBlk \<infinity> (\<lambda>_. State \<sigma>\<^sub>p) ({ch}, {})]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S}))} (Cm (ch[!]e)) {P}"
| RecvH: "\<turnstile> {(\<lambda>S. P ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p(var := v), l @ [InBlock ch v]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union>
  {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(var := v), l @ [WaitBlk d (\<lambda>_. State \<sigma>\<^sub>p) ({}, {ch}), InBlock ch v]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d v. (d::real) > 0 
  \<and> (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union>
  {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [WaitBlk \<infinity> (\<lambda>_. State \<sigma>\<^sub>p) ({}, {ch})]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S}))} (Cm (ch[?]var)) {P}"
| ContH: "\<turnstile> {(\<lambda>S. P ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S \<and> \<not> b \<sigma>\<^sub>p} \<union> 
  {(\<sigma>\<^sub>l, p d, l @ [WaitBlk d (\<lambda>\<tau>. State (p \<tau>)) ({}, {})]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l p d. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S \<and> d > 0 \<and> 
  ODEsol ode p d \<and> (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (p t)) \<and> \<not>b (p d) \<and> p 0 = \<sigma>\<^sub>p}))} (Cont ode b) {P}"
| InterruptH1: "interrupt_hoare P 0 ode b cs 
  (exists (\<lambda>S0. \<lambda>S. P S0 \<and> (\<exists>S1 S2. S1 = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> \<not> b \<sigma>\<^sub>p} \<and>
  S2 = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p', l @ [WaitBlk d (\<lambda> \<tau>. State (sl \<tau>)) (rdy_of_echoice cs)]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d sl \<sigma>\<^sub>p'. 
  (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> d > 0 \<and> ODEsol ode sl d \<and> (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (sl t)) \<and> \<not> b (sl d) 
  \<and> sl 0 = \<sigma>\<^sub>p \<and> sl d = \<sigma>\<^sub>p'} \<and> S = S1 \<union> S2)))"
| InterruptH2:"\<lbrakk>\<turnstile> {exists (\<lambda>S0. \<lambda>S. P S0 \<and> (\<exists>S1 S2. S1 = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [OutBlock ch (e \<sigma>\<^sub>p)])|\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0} 
  \<and> S2 = {(\<sigma>\<^sub>l, sl d, l @ [WaitBlk d (\<lambda>\<tau>. State (sl \<tau>)) (rdy_of_echoice cs), OutBlock ch (e (sl d))]) 
  |\<sigma>\<^sub>l \<sigma>\<^sub>p l d sl. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> d > 0 \<and> ODEsol ode sl d \<and> sl 0 = \<sigma>\<^sub>p \<and> (\<forall>t. t \<ge> 0 \<and> t < d 
  \<longrightarrow> b (sl t))} \<and> S = S1 \<union> S2))} C {Q};  cs ! n = (ch[!]e, C); interrupt_hoare P n ode b cs R \<rbrakk> 
  \<Longrightarrow> interrupt_hoare P (Suc n) ode b cs (join R Q)"
| InterruptH3: "\<lbrakk>\<turnstile> {exists (\<lambda>S0. \<lambda>S. P S0 \<and> (\<exists>S1 S2. S1 = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(var := v), l @ [InBlock ch v]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0} 
  \<and> S2 = {(\<sigma>\<^sub>l, (sl d)(var := v), l @ [WaitBlk d (\<lambda>\<tau>. State (sl \<tau>)) (rdy_of_echoice cs), InBlock ch v]) 
  |\<sigma>\<^sub>l \<sigma>\<^sub>p l d sl v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> d > 0 \<and> ODEsol ode sl d \<and> sl 0 = \<sigma>\<^sub>p \<and> (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (sl t))} \<and> S = S1 \<union> S2))} C {Q};
  cs ! n = (ch[?]var, C); interrupt_hoare P n ode b cs R\<rbrakk> \<Longrightarrow> interrupt_hoare P (Suc n) ode b cs (join R Q)"
| InterruptH4: "interrupt_hoare P (length cs) ode b cs Q \<Longrightarrow> \<turnstile> {P} Interrupt ode b cs {Q}"
| ExistsH: "\<lbrakk>\<And>x::('lvar, 'lval)conf set. \<turnstile> {P x} C {Q x}\<rbrakk> \<Longrightarrow> \<turnstile> {exists P} C {exists Q}"

inductive big_step_interrupt :: "nat \<Rightarrow> ODE \<Rightarrow> fform \<Rightarrow> (comm \<times> proc) list \<Rightarrow> state \<Rightarrow> trace \<Rightarrow> state \<Rightarrow> bool" where
  "i < n \<Longrightarrow> cs ! i = (Send ch e, p2) \<Longrightarrow>
   big_step p2 s tr2 s2 \<Longrightarrow>
   big_step_interrupt n ode b cs s (OutBlock ch (e s) # tr2) s2"
| "d > 0 \<Longrightarrow> ODEsol ode p d \<Longrightarrow> p 0 = s1 \<Longrightarrow>
   (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (p t)) \<Longrightarrow>
   i < n \<Longrightarrow> cs ! i = (Send ch e, p2) \<Longrightarrow>
   rdy = rdy_of_echoice cs \<Longrightarrow>
   big_step p2 (p d) tr2 s2 \<Longrightarrow>
   big_step_interrupt n ode b cs s1 (WaitBlk d (\<lambda>\<tau>. State (p \<tau>)) rdy #
                                     OutBlock ch (e (p d)) # tr2) s2"
| "i < n \<Longrightarrow> cs ! i = (Receive ch var, p2) \<Longrightarrow>
   big_step p2 (s(var := v)) tr2 s2 \<Longrightarrow>
   big_step_interrupt n ode b cs s (InBlock ch v # tr2) s2"
| "d > 0 \<Longrightarrow> ODEsol ode p d \<Longrightarrow> p 0 = s1 \<Longrightarrow>
   (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (p t)) \<Longrightarrow>
   i < n \<Longrightarrow> cs ! i = (Receive ch var, p2) \<Longrightarrow>
   rdy = rdy_of_echoice cs \<Longrightarrow>
   big_step p2 ((p d)(var := v)) tr2 s2 \<Longrightarrow>
   big_step_interrupt n ode b cs s1 (WaitBlk d (\<lambda>\<tau>. State (p \<tau>)) rdy #
                                     InBlock ch v # tr2) s2"
| "\<not>b s \<Longrightarrow> big_step_interrupt n ode b cs s [] s"
| "d > 0 \<Longrightarrow> ODEsol ode p d \<Longrightarrow>
   (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (p t)) \<Longrightarrow>
   \<not>b (p d) \<Longrightarrow> p 0 = s1 \<Longrightarrow> p d = s2 \<Longrightarrow>
   rdy = rdy_of_echoice cs \<Longrightarrow>
   big_step_interrupt n ode b cs s1 [WaitBlk d (\<lambda>\<tau>. State (p \<tau>)) rdy] s2"

inductive_cases big_step_interruptE: "big_step_interrupt n ode b cs s1 tr s2"

(*
lemma interrupt_hoare_cons: 
  assumes "entails P P'"
      and "entails Q' Q"
      and "interrupt_hoare P' n ode b cs Q'"
    shows"interrupt_hoare P n ode b cs Q"
*)
lemma big_step_Suc_impl:
  "big_step_interrupt n ode b cs \<sigma>\<^sub>p l \<sigma>\<^sub>p' \<Longrightarrow>big_step_interrupt (Suc n) ode b cs \<sigma>\<^sub>p l \<sigma>\<^sub>p'"
  apply (rule big_step_interruptE, simp)
       apply (metis big_step_interrupt.intros(1) less_Suc_eq)
      apply (metis big_step_interrupt.intros(2) less_SucI)
     apply (metis big_step_interrupt.intros(3) less_SucI)
    apply (metis big_step_interrupt.intros(4) less_SucI)
   apply (metis big_step_interrupt.intros(5))
  by (simp add: big_step_interrupt.intros(6))
           

definition sem_interrupt :: "nat \<Rightarrow> ODE \<Rightarrow> fform \<Rightarrow> (comm \<times> proc) list \<Rightarrow> ('lvar, 'lval)conf set \<Rightarrow> ('lvar, 'lval)conf set"
  where "sem_interrupt n ode b cs \<Sigma> = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p', l @ l') |\<sigma>\<^sub>l \<sigma>\<^sub>p \<sigma>\<^sub>p' l l'. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma> \<and> 
                                        big_step_interrupt n ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'}"


lemma in_sem_interrupt: 
  "\<phi> \<in> sem_interrupt n ode b cs \<Sigma> \<longleftrightarrow> (\<exists>\<sigma>\<^sub>p l l'. (fst \<phi>, \<sigma>\<^sub>p, l) \<in> \<Sigma> \<and> 
   big_step_interrupt n ode b cs \<sigma>\<^sub>p l' (fst (snd \<phi>)) \<and> snd (snd \<phi>) = l @ l')" (is "?A = ?B")
proof
  assume ?A
  then obtain \<sigma>\<^sub>l \<sigma>\<^sub>p \<sigma>\<^sub>p' l l' where "\<phi> = (\<sigma>\<^sub>l, \<sigma>\<^sub>p', l @ l')" "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>"  
  "big_step_interrupt n ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'"
    using sem_interrupt_def[of n ode b cs \<Sigma>] by auto
  then show ?B
    by auto
next
  show "?B \<Longrightarrow> ?A"
    by (metis (mono_tags, lifting) CollectI prod.collapse sem_interrupt_def)
qed

lemma sem_interrupt_0: 
  "sem_interrupt 0 ode b cs \<Sigma> = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma> \<and> \<not> b \<sigma>\<^sub>p} \<union>
  {(\<sigma>\<^sub>l, \<sigma>\<^sub>p', l @ [WaitBlk d (\<lambda> \<tau>. State (sl \<tau>)) rdy]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d sl rdy \<sigma>\<^sub>p'. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma> \<and> 
   d > 0 \<and> ODEsol ode sl d \<and> (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (sl t)) \<and> \<not> b (sl d) \<and> sl 0 = \<sigma>\<^sub>p \<and> sl d = \<sigma>\<^sub>p' 
   \<and> rdy = rdy_of_echoice cs}" (is "?A = ?B \<union> ?C")
proof
  show "?A \<subseteq> ?B \<union> ?C"
  proof(rule subsetTupleI)
    fix \<sigma>\<^sub>l \<sigma>\<^sub>p' tr
    assume "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?A"
    then obtain \<sigma>\<^sub>p l l'  where "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>" "big_step_interrupt 0 ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'" "tr = l @ l'"
      by (smt (verit, best) Pair_inject mem_Collect_eq sem_interrupt_def)
    then show "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?B \<union> ?C"
      apply (rule_tac big_step_interruptE[of 0 ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'], simp)
      by blast+
  qed
next
  show "?B \<union> ?C \<subseteq> ?A"
  proof(rule Un_least)+
    show "?B \<subseteq> ?A"
    proof(rule subsetTupleI)
      fix \<sigma>\<^sub>l \<sigma>\<^sub>p l
      assume "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> ?B"
      then have "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>" "\<not> b \<sigma>\<^sub>p"
        by auto
      then show "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> ?A"
        using in_sem_interrupt[of "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l)" 0 ode b cs \<Sigma>]
        by (metis append.right_neutral big_step_interrupt.intros(5) split_pairs)         
    qed
    show "?C \<subseteq> ?A"
    proof(rule subsetTupleI)
      fix \<sigma>\<^sub>l \<sigma>\<^sub>p' tr
      assume "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?C"
      then obtain \<sigma>\<^sub>p d rdy l sl where asm0: "tr = l @ [WaitBlk (ereal d) (\<lambda>\<tau>. State (sl \<tau>)) rdy]"
      "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>" "0 < d" "ODEsol ode sl d" "\<forall>t. 0 \<le> t \<and> t < d \<longrightarrow> b (sl t)"
      "\<not> b (sl d)" "sl 0 = \<sigma>\<^sub>p" "sl d = \<sigma>\<^sub>p'" "rdy = rdy_of_echoice cs"
        by auto
      then have "big_step_interrupt 0 ode b cs \<sigma>\<^sub>p [WaitBlk d (\<lambda>\<tau>. State (sl \<tau>)) rdy] \<sigma>\<^sub>p'"
        using big_step_interrupt.intros(6) by blast
      with asm0(1) asm0(2) show "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?A"
        using in_sem_interrupt[of "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr)" 0 ode b cs \<Sigma>]
        by auto
    qed
  qed
qed

lemma sem_interrupt_Suc_Send:
  assumes "cs ! n = (ch[!]e, C)"
  shows "sem_interrupt (Suc n) ode b cs \<Sigma> = sem_interrupt n ode b cs \<Sigma> \<union> 
  {(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr0 @ OutBlock ch (e \<sigma>\<^sub>p) # tr1) |\<sigma>\<^sub>l \<sigma>\<^sub>p tr0 tr1 \<sigma>\<^sub>p'. 
  (\<sigma>\<^sub>l, \<sigma>\<^sub>p, tr0) \<in> \<Sigma> \<and> big_step C \<sigma>\<^sub>p tr1 \<sigma>\<^sub>p'} \<union> 
  {(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr0 @ [WaitBlk d (\<lambda>\<tau>. State (sl \<tau>)) (rdy_of_echoice cs), OutBlock ch (e (sl d))] @ tr1) 
  |\<sigma>\<^sub>l \<sigma>\<^sub>p tr0 d sl tr1 \<sigma>\<^sub>p'. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, tr0) \<in> \<Sigma> \<and> d > 0 \<and> ODEsol ode sl d \<and> sl 0 = \<sigma>\<^sub>p \<and>
  (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (sl t)) \<and> big_step C (sl d) tr1 \<sigma>\<^sub>p'}" (is "?A = ?B \<union> ?C \<union> ?D")
proof
  show "?A \<subseteq> ?B \<union> ?C \<union> ?D"
  proof(rule subsetTupleI)
    fix \<sigma>\<^sub>l \<sigma>\<^sub>p' tr
    assume "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?A"
    then obtain \<sigma>\<^sub>p l l'  where "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>" "big_step_interrupt (Suc n) ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'" "tr = l @ l'"
      by (smt (verit, best) Pair_inject mem_Collect_eq sem_interrupt_def)
    then show "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?B \<union> ?C \<union> ?D"
    proof(rule_tac big_step_interruptE[of "Suc n" ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'])
      show "big_step_interrupt (Suc n) ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'"
        by (simp add: \<open>big_step_interrupt (Suc n) ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'\<close>)
    next
      fix i cha ea p2 tr2
      assume a: "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>" "big_step_interrupt (Suc n) ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'"  "tr = l @ l'"
      "l' = OutBlock cha (ea \<sigma>\<^sub>p) # tr2" "i < Suc n"  "cs ! i = (cha[!]ea, p2)" " big_step p2 \<sigma>\<^sub>p tr2 \<sigma>\<^sub>p'"
      then show ?thesis (is "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?A0 \<union> ?B0 \<union> ?C0")
      proof(cases "i = n")
        assume "i = n"
        with a assms have "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?B0"
          apply(rule_tac big_step_interruptE[of "Suc n" ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'], simp)
          by auto
        then show "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?A0 \<union> ?B0 \<union> ?C0" by auto
      next
        assume "i \<noteq> n"
        with a(5) have "i < n"
          by auto
        with a have "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?A0"
          using big_step_interrupt.intros(1) in_sem_interrupt by fastforce
        then show "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?A0 \<union> ?B0 \<union> ?C0" by auto
      qed
    next
      fix d p i cha ea p2 tr2
      assume b: "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>" "big_step_interrupt (Suc n) ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'"
      "tr = l @ l'" "l' = WaitBlk (ereal d) (\<lambda>\<tau>. State (p \<tau>)) (rdy_of_echoice cs) # OutBlock cha (ea (p d)) # tr2"
      "0 < d" "ODEsol ode p d" "p 0 = \<sigma>\<^sub>p" "\<forall>t. 0 \<le> t \<and> t < d \<longrightarrow> b (p t)" "i < Suc n" "cs ! i = (cha[!]ea, p2)"
      "big_step p2 (p d) tr2 \<sigma>\<^sub>p'"
      then show ?thesis (is "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?A1 \<union> ?B1 \<union> ?C1")
      proof(cases "i = n")
        assume "i = n"
        with b assms have "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?C1"
          by auto
        then show "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?A1 \<union> ?B1 \<union> ?C1"
          by auto
      next
        assume "i \<noteq> n"
        with b(9) have "i < n" 
          by auto
        with b have "big_step_interrupt n ode b cs \<sigma>\<^sub>p (WaitBlk (ereal d) (\<lambda>\<tau>. State (p \<tau>)) 
                    (rdy_of_echoice cs) # OutBlock cha (ea (p d)) # tr2) \<sigma>\<^sub>p'"
          using big_step_interrupt.intros(2) by auto
        with b have "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?A1"
          using in_sem_interrupt by fastforce
        then show "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?A1 \<union> ?B1 \<union> ?C1"
          by auto
      qed
    next
      fix i ch var p2 v tr2
      assume c: "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>" "cs ! i = (ch[?]var, p2)" "big_step_interrupt (Suc n) ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'"
      "tr = l @ l'" "l' = InBlock ch v # tr2" "i < Suc n" "cs ! i = (ch[?]var, p2)"
      "big_step p2 (\<sigma>\<^sub>p(var := v)) tr2 \<sigma>\<^sub>p'"
      then show ?thesis
      proof(cases "i = n")
        assume "i = n"
        with c(2) assms(1) show ?thesis
          by auto
      next
        assume "i \<noteq> n"
        with c(6) have "i < n"
          by auto
        with c have "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> sem_interrupt n ode b cs \<Sigma>"
          using big_step_interrupt.intros(3) sem_interrupt_def by fastforce
        then show ?thesis by auto
      qed
    next
      fix d p i ch var p2 v tr2
      assume c: "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>" "big_step_interrupt (Suc n) ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'" "tr = l @ l'" 
      "l' = WaitBlk (ereal d) (\<lambda>\<tau>. State (p \<tau>)) (rdy_of_echoice cs) # InBlock ch v # tr2"
      "0 < d" "ODEsol ode p d" "p 0 = \<sigma>\<^sub>p" "\<forall>t. 0 \<le> t \<and> t < d \<longrightarrow> b (p t)" "i < Suc n" 
      "cs ! i = (ch[?]var, p2)" "big_step p2 ((p d)(var := v)) tr2 \<sigma>\<^sub>p'"
      then show ?thesis
      proof(case_tac "i = n")
        assume "i = n"
        with assms(1) c(10) show ?thesis
          by auto
      next
        assume "i \<noteq> n"
        with c(9) have "i < n"
          by auto
        with c have "big_step_interrupt n ode b cs \<sigma>\<^sub>p 
        (WaitBlk (ereal d) (\<lambda>\<tau>. State (p \<tau>)) (rdy_of_echoice cs) # InBlock ch v # tr2) \<sigma>\<^sub>p'"
          using big_step_interrupt.intros(4) by auto
        with c have "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> sem_interrupt n ode b cs \<Sigma>"
          using in_sem_interrupt by fastforce
        then show ?thesis
          by auto
      qed
    next
      assume "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>" "big_step_interrupt (Suc n) ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'" "tr = l @ l'" 
              "l' = []" "\<sigma>\<^sub>p' = \<sigma>\<^sub>p" "\<not> b \<sigma>\<^sub>p"
      then have "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> sem_interrupt n ode b cs \<Sigma>"
        by (metis big_step_interrupt.intros(5) in_sem_interrupt split_pairs)
      then show ?thesis
        by auto
    next
      fix d p
      assume d: "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>" "big_step_interrupt (Suc n) ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'" "tr = l @ l'" 
      "l' = [WaitBlk (ereal d) (\<lambda>\<tau>. State (p \<tau>)) (rdy_of_echoice cs)]" "0 < d" "ODEsol ode p d" 
      "\<forall>t. 0 \<le> t \<and> t < d \<longrightarrow> b (p t)" "\<not> b \<sigma>\<^sub>p'" "p 0 = \<sigma>\<^sub>p" "p d = \<sigma>\<^sub>p'"
      then have "big_step_interrupt n ode b cs \<sigma>\<^sub>p [WaitBlk (ereal d) (\<lambda>\<tau>. State (p \<tau>)) (rdy_of_echoice cs)] \<sigma>\<^sub>p'"
        using big_step_interrupt.intros(6) by auto
      with d have "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> sem_interrupt n ode b cs \<Sigma>"
        using sem_interrupt_def by fastforce
      then show ?thesis
        by auto
    qed
  qed
next
  show "?B \<union> ?C \<union> ?D \<subseteq> ?A"
  proof(rule Un_least)+
    show "?B \<subseteq> ?A"
      by (meson big_step_Suc_impl in_sem_interrupt subsetI)
  next
    from assms show "?C \<subseteq> ?A"
      apply (simp add: sem_interrupt_def, clarsimp)
      by (metis big_step_interrupt.intros(1) lessI)
  next
    from assms show "?D \<subseteq> ?A"
      apply (simp add: sem_interrupt_def, clarsimp)
      by (metis big_step_interrupt.intros(2) lessI)
  qed
qed

lemma sem_interrupt_Suc_Recv:
  assumes "cs ! n = (ch[?]var, C)"
  shows "sem_interrupt (Suc n) ode b cs \<Sigma> = sem_interrupt n ode b cs \<Sigma> \<union> 
  {(\<sigma>\<^sub>l, \<sigma>\<^sub>p', l @ InBlock ch v # l') |\<sigma>\<^sub>l \<sigma>\<^sub>p l l' \<sigma>\<^sub>p' v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma> \<and> big_step C (\<sigma>\<^sub>p(var := v)) l' \<sigma>\<^sub>p'} \<union> 
  {(\<sigma>\<^sub>l, \<sigma>\<^sub>p', l @ [WaitBlk d (\<lambda>\<tau>. State (sl \<tau>)) (rdy_of_echoice cs), InBlock ch v] @ l')
  |\<sigma>\<^sub>l \<sigma>\<^sub>p l l' \<sigma>\<^sub>p' d sl v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma> \<and> d > 0 \<and> ODEsol ode sl d \<and> sl 0 = \<sigma>\<^sub>p \<and> 
  (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (sl t)) \<and> big_step C ((sl d)(var := v)) l' \<sigma>\<^sub>p'}"  (is "?A = ?B \<union> ?C \<union> ?D")
proof
  show "?A \<subseteq> ?B \<union> ?C \<union> ?D"
  proof(rule subsetTupleI)
    fix \<sigma>\<^sub>l \<sigma>\<^sub>p' tr
    assume "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?A"
    then obtain \<sigma>\<^sub>p l l'  where "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>" "big_step_interrupt (Suc n) ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'" "tr = l @ l'"
      by (smt (verit, best) Pair_inject mem_Collect_eq sem_interrupt_def)
    then show "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?B \<union> ?C \<union> ?D"
    proof(rule_tac big_step_interruptE[of "Suc n" ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'])
      show "big_step_interrupt (Suc n) ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'"
        by (simp add: \<open>big_step_interrupt (Suc n) ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'\<close>)
    next
      fix i cha ea p2 tr2
      assume a: "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>" "big_step_interrupt (Suc n) ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'"  "tr = l @ l'"
      "l' = OutBlock cha (ea \<sigma>\<^sub>p) # tr2" "i < Suc n"  "cs ! i = (cha[!]ea, p2)" " big_step p2 \<sigma>\<^sub>p tr2 \<sigma>\<^sub>p'"
      then show ?thesis
      proof(cases "i = n")
        assume "i = n"
        with a(6) assms show ?thesis
          by auto
      next
        assume "i \<noteq> n"
        with a(5) have "i < n"
          by auto
        with a have "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> sem_interrupt n ode b cs \<Sigma>"
          using big_step_interrupt.intros(1) in_sem_interrupt by fastforce
        then show ?thesis by auto
      qed
    next
      fix d p i cha ea p2 tr2
      assume b: "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>" "big_step_interrupt (Suc n) ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'"
      "tr = l @ l'" "l' = WaitBlk (ereal d) (\<lambda>\<tau>. State (p \<tau>)) (rdy_of_echoice cs) # OutBlock cha (ea (p d)) # tr2"
      "0 < d" "ODEsol ode p d" "p 0 = \<sigma>\<^sub>p" "\<forall>t. 0 \<le> t \<and> t < d \<longrightarrow> b (p t)" "i < Suc n" "cs ! i = (cha[!]ea, p2)"
      "big_step p2 (p d) tr2 \<sigma>\<^sub>p'"
      then show ?thesis
      proof(cases "i = n")
        assume "i = n"
        with b(10) assms show ?thesis
          by auto
      next
        assume "i \<noteq> n"
        with b(9) have "i < n" 
          by auto
        with b have "big_step_interrupt n ode b cs \<sigma>\<^sub>p (WaitBlk (ereal d) (\<lambda>\<tau>. State (p \<tau>)) 
                    (rdy_of_echoice cs) # OutBlock cha (ea (p d)) # tr2) \<sigma>\<^sub>p'"
          using big_step_interrupt.intros(2) by auto
        with b have "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> sem_interrupt n ode b cs \<Sigma>"
          using in_sem_interrupt by fastforce
        then show ?thesis
          by auto
      qed
    next
      fix i ch var p2 v tr2
      assume c: "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>" "cs ! i = (ch[?]var, p2)" "big_step_interrupt (Suc n) ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'"
      "tr = l @ l'" "l' = InBlock ch v # tr2" "i < Suc n" "cs ! i = (ch[?]var, p2)"
      "big_step p2 (\<sigma>\<^sub>p(var := v)) tr2 \<sigma>\<^sub>p'"
      then show ?thesis (is "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?A0 \<union> ?B0 \<union> ?C0")
      proof(cases "i = n")
        assume "i = n"
        with c assms have "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?B0"
          by auto
        then show ?thesis
          by auto
      next
        assume "i \<noteq> n"
        with c(6) have "i < n"
          by auto
        with c have "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?A0"
          using big_step_interrupt.intros(3) sem_interrupt_def by fastforce
        then show ?thesis
          by auto
      qed
    next
      fix d p i ch var p2 v tr2
      assume c: "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>" "big_step_interrupt (Suc n) ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'" "tr = l @ l'" 
      "l' = WaitBlk (ereal d) (\<lambda>\<tau>. State (p \<tau>)) (rdy_of_echoice cs) # InBlock ch v # tr2"
      "0 < d" "ODEsol ode p d" "p 0 = \<sigma>\<^sub>p" "\<forall>t. 0 \<le> t \<and> t < d \<longrightarrow> b (p t)" "i < Suc n" 
      "cs ! i = (ch[?]var, p2)" "big_step p2 ((p d)(var := v)) tr2 \<sigma>\<^sub>p'"
      then show ?thesis (is "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?A1 \<union> ?B1 \<union> ?C1")
      proof(case_tac "i = n")
        assume "i = n"
        with c assms have "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> ?C1"
          apply auto
          by (rule_tac x = l in exI, rule_tac x = tr2 in exI, rule_tac x = d in exI, 
                rule_tac x = p in exI, rule_tac x = v in exI, simp)
        then show ?thesis
          by auto
      next
        assume "i \<noteq> n"
        with c(9) have "i < n"
          by auto
        with c have "big_step_interrupt n ode b cs \<sigma>\<^sub>p 
        (WaitBlk (ereal d) (\<lambda>\<tau>. State (p \<tau>)) (rdy_of_echoice cs) # InBlock ch v # tr2) \<sigma>\<^sub>p'"
          using big_step_interrupt.intros(4) by auto
        with c have "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> sem_interrupt n ode b cs \<Sigma>"
          using in_sem_interrupt by fastforce
        then show ?thesis
          by auto
      qed
    next
      assume "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>" "big_step_interrupt (Suc n) ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'" "tr = l @ l'" 
              "l' = []" "\<sigma>\<^sub>p' = \<sigma>\<^sub>p" "\<not> b \<sigma>\<^sub>p"
      then have "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> sem_interrupt n ode b cs \<Sigma>"
        by (metis big_step_interrupt.intros(5) in_sem_interrupt split_pairs)
      then show ?thesis
        by auto
    next
      fix d p
      assume d: "(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>" "big_step_interrupt (Suc n) ode b cs \<sigma>\<^sub>p l' \<sigma>\<^sub>p'" "tr = l @ l'" 
      "l' = [WaitBlk (ereal d) (\<lambda>\<tau>. State (p \<tau>)) (rdy_of_echoice cs)]" "0 < d" "ODEsol ode p d" 
      "\<forall>t. 0 \<le> t \<and> t < d \<longrightarrow> b (p t)" "\<not> b \<sigma>\<^sub>p'" "p 0 = \<sigma>\<^sub>p" "p d = \<sigma>\<^sub>p'"
      then have "big_step_interrupt n ode b cs \<sigma>\<^sub>p [WaitBlk (ereal d) (\<lambda>\<tau>. State (p \<tau>)) (rdy_of_echoice cs)] \<sigma>\<^sub>p'"
        using big_step_interrupt.intros(6) by auto
      with d have "(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr) \<in> sem_interrupt n ode b cs \<Sigma>"
        using sem_interrupt_def by fastforce
      then show ?thesis
        by auto
    qed
  qed
next
  show "?B \<union> ?C \<union> ?D \<subseteq> ?A"
  proof(rule Un_least)+
    show "?B \<subseteq> ?A"
      by (meson big_step_Suc_impl in_sem_interrupt subsetI)
  next
    from assms show "?C \<subseteq> ?A"
      apply (simp add: sem_interrupt_def, clarsimp)
      by (metis big_step_interrupt.intros(3) less_Suc_eq)
  next
    from assms show "?D \<subseteq> ?A"
      apply (simp add: sem_interrupt_def, clarsimp)
      by (metis big_step_interrupt.intros(4) lessI)
  qed
qed

lemma big_step_interrupt_final:
  "big_step_interrupt (length es) ode b es s1 tr s2 \<longleftrightarrow> big_step (Interrupt ode b es) s1 tr s2"
  apply (rule iffI)
  apply (auto elim!: interruptE big_step_interruptE)
  by (auto intro: big_step.intros big_step_interrupt.intros)

lemma sem_interrupt_final:
  "sem_interrupt (length cs) ode b cs \<Sigma> = sem (Interrupt ode b cs) \<Sigma>"
  by (simp add: sem_interrupt_def sem_def big_step_interrupt_final)

definition interrupt_Valid :: "('lvar, 'lval) assn \<Rightarrow> nat \<Rightarrow> ODE \<Rightarrow> fform \<Rightarrow> (comm \<times> proc) list \<Rightarrow> ('lvar, 'lval) assn \<Rightarrow> bool" where
  "interrupt_Valid P n ode b cs Q \<longleftrightarrow> (\<forall>\<Sigma>. P \<Sigma> \<longrightarrow> Q (sem_interrupt n ode b cs \<Sigma>))"


theorem soundness:
  "(\<turnstile> {P} C {Q} \<longrightarrow> \<Turnstile> {P} C {Q}) \<and>
   (interrupt_hoare P n ode b cs Q \<longrightarrow> interrupt_Valid P n ode b cs Q)"
proof(induct rule: hoare_interrupt_hoare.induct)
  case (SkipH P)
  then show ?case
    by (simp add: skip_rule)
next
  case (ConsH P P' Q' Q C)
  then show ?case
    by (simp add: consequence_rule)
next
  case (AssignH P x e)
  then show ?case
    by (simp add: assign_rule)
next
  case (HavocH P x)
  then show ?case
    using havoc_rule by blast
next
  case (SeqH P C1 R C2 Q)
  then show ?case
    by (simp add: seq_rule)
next
  case (AssumeH P b)
  then show ?case
    by (simp add: assume_sem hyper_hoare_tripleI)
next
  case (IChoiceH P C1 Q1 C2 Q2)
  then show ?case
    by (simp add: if_rule)
next
  case (RepH I C)
  then show ?case
    by (simp add: while_rule)
next
  case (SendH P ch e)
  then show ?case
    using send_rule by blast
next
  case (RecvH P var ch)
  then show ?case
    using recv_rule by blast
next
  case (ContH P b ode)
  then show ?case
    using rule_cont by blast
next
  case (InterruptH1 P ode b cs)
  then show ?case (is "interrupt_Valid P 0 ode b cs ?Q")
  proof-
    {
      fix \<Sigma>
      assume a0: "P \<Sigma>"
      let ?S1 = "{(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma> \<and> \<not> b \<sigma>\<^sub>p}"
      let ?S2 = "{(\<sigma>\<^sub>l, \<sigma>\<^sub>p', l @ [WaitBlk d (\<lambda> \<tau>. State (sl \<tau>)) (rdy_of_echoice cs)]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d sl \<sigma>\<^sub>p'. 
      (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma> \<and> d > 0 \<and> ODEsol ode sl d \<and> (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (sl t)) \<and> \<not> b (sl d) \<and> 
      sl 0 = \<sigma>\<^sub>p \<and> sl d = \<sigma>\<^sub>p'}"
      from a0 have "?Q (?S1 \<union> ?S2)"
        by (simp add: exists_def, rule_tac x = "\<Sigma>" in exI, simp)
    }
    then show ?thesis
      using interrupt_Valid_def
      by (metis (mono_tags, lifting) sem_interrupt_0)
  qed
next
  case (InterruptH2 P ch e cs ode b C Q n R)
  then show ?case
  proof(unfold interrupt_Valid_def, clarify)
    fix \<Sigma>
    assume b0: "P \<Sigma>"
    let ?S1 = "{(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [OutBlock ch (e \<sigma>\<^sub>p)]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>}"
    and ?S2 = "{(\<sigma>\<^sub>l, sl d, l @ [WaitBlk (ereal d) (\<lambda>\<tau>. State (sl \<tau>)) (rdy_of_echoice cs), OutBlock ch (e (sl d))]) 
    |\<sigma>\<^sub>l \<sigma>\<^sub>p l d sl. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma> \<and> 0 < d \<and> ODEsol ode sl d \<and> sl 0 = \<sigma>\<^sub>p \<and> (\<forall>t. 0 \<le> t \<and> t < d \<longrightarrow> b (sl t))}"
    and ?P = "exists (\<lambda>S0 S. P S0 \<and> (\<exists>S1 S2. S1 = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [OutBlock ch (e \<sigma>\<^sub>p)]) 
    |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0} \<and> S2 = {(\<sigma>\<^sub>l, sl d, l @ [WaitBlk (ereal d) (\<lambda>\<tau>. State (sl \<tau>)) (rdy_of_echoice cs), 
    OutBlock ch (e (sl d))]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d sl. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> 0 < d \<and> ODEsol ode sl d \<and> sl 0 = \<sigma>\<^sub>p 
    \<and> (\<forall>t. 0 \<le> t \<and> t < d \<longrightarrow> b (sl t))} \<and> S = S1 \<union> S2))"
    from b0 have "?P (?S1 \<union> ?S2)"
      by (simp add: exists_def, rule_tac x = \<Sigma> in exI, simp)
    with InterruptH2.hyps(2) have "Q (sem C (?S1 \<union> ?S2))"
      using hyper_hoare_tripleE by blast
    then have b1: "Q (sem C ?S1 \<union> sem C ?S2)"
      by (simp add: sem_union)
    let ?R1 = "{(\<sigma>\<^sub>l, \<sigma>\<^sub>p', tr0 @ OutBlock ch (e \<sigma>\<^sub>p) # tr1) |\<sigma>\<^sub>l \<sigma>\<^sub>p tr0 tr1 \<sigma>\<^sub>p'. 
               (\<sigma>\<^sub>l, \<sigma>\<^sub>p, tr0) \<in> \<Sigma> \<and> big_step C \<sigma>\<^sub>p tr1 \<sigma>\<^sub>p'}"
    let ?R2 = "{(\<sigma>\<^sub>l, \<sigma>\<^sub>p',tr0 @ [WaitBlk d (\<lambda>\<tau>. State (sl \<tau>)) (rdy_of_echoice cs), OutBlock ch (e (sl d))] @ tr1) 
    |\<sigma>\<^sub>l \<sigma>\<^sub>p tr0 d sl tr1 \<sigma>\<^sub>p'. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, tr0) \<in> \<Sigma> \<and> d > 0 \<and> ODEsol ode sl d \<and> sl 0 = \<sigma>\<^sub>p \<and>
    (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (sl t)) \<and> big_step C (sl d) tr1 \<sigma>\<^sub>p'}"
    have "sem C ?S1 = ?R1"  "sem C ?S2 = ?R2"
       apply (simp add: sem_interrupt_send1)
      by (metis sem_interrupt_send2)
    with b1 have b2: "Q (?R1 \<union> ?R2)"
      by auto
    from InterruptH2.hyps(5) b0 have "R (sem_interrupt n ode b cs \<Sigma>)"
      by (simp add: interrupt_Valid_def)
    then have "(join R Q) ((sem_interrupt n ode b cs \<Sigma>) \<union> (?R1 \<union> ?R2))"
      using b2 joinI by blast
    with InterruptH2.hyps(3) show "(join R Q) (sem_interrupt (Suc n) ode b cs \<Sigma>)"
      using sem_interrupt_Suc_Send[of cs n ch e C ode b \<Sigma>]
      by (simp add: sup_assoc)
  qed
next
  case (InterruptH3 P var ch cs ode b C Q n R)
  then show ?case
  proof(unfold interrupt_Valid_def, clarify)
    fix \<Sigma>
    assume c0: "P \<Sigma>"
    let ?S1 = "{(\<sigma>\<^sub>l, \<sigma>\<^sub>p(var := v), l @ [InBlock ch v]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>}"
    and ?S2 = "{(\<sigma>\<^sub>l, (sl d)(var := v), l @ [WaitBlk (ereal d) (\<lambda>\<tau>. State (sl \<tau>)) (rdy_of_echoice cs), InBlock ch v])
    |\<sigma>\<^sub>l \<sigma>\<^sub>p l d sl v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma> \<and> 0 < d \<and> ODEsol ode sl d \<and> sl 0 = \<sigma>\<^sub>p \<and> (\<forall>t. 0 \<le> t \<and> t < d \<longrightarrow> b (sl t))}"
    and ?P = "exists (\<lambda>S0 S. P S0 \<and> (\<exists>S1 S2. S1 = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(var := v), l @ [InBlock ch v]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0} \<and>
    S2 = {(\<sigma>\<^sub>l, (sl d)(var := v), l @ [WaitBlk (ereal d) (\<lambda>\<tau>. State (sl \<tau>)) (rdy_of_echoice cs), InBlock ch v])
    |\<sigma>\<^sub>l \<sigma>\<^sub>p l d sl v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> 0 < d \<and> ODEsol ode sl d \<and> sl 0 = \<sigma>\<^sub>p \<and> (\<forall>t. 0 \<le> t \<and> t < d \<longrightarrow> b (sl t))}
    \<and> S = S1 \<union> S2))"
    from c0 have "?P (?S1 \<union> ?S2)"
      by (simp add: exists_def, rule_tac x = \<Sigma> in exI, simp)
    with InterruptH3.hyps(2) have "Q (sem C (?S1 \<union> ?S2))"
        using hyper_hoare_tripleE by blast
    then have c1: "Q (sem C ?S1 \<union> sem C ?S2)"
      by (simp add: sem_union)
    let ?R1 = "{(\<sigma>\<^sub>l, \<sigma>\<^sub>p', l @ InBlock ch v # l') |\<sigma>\<^sub>l \<sigma>\<^sub>p l l' \<sigma>\<^sub>p' v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma> \<and> big_step C (\<sigma>\<^sub>p(var := v)) l' \<sigma>\<^sub>p'}"
    let ?R2 = "{(\<sigma>\<^sub>l, \<sigma>\<^sub>p', l @ [WaitBlk d (\<lambda>\<tau>. State (sl \<tau>)) (rdy_of_echoice cs), InBlock ch v] @ l')
    |\<sigma>\<^sub>l \<sigma>\<^sub>p l l' \<sigma>\<^sub>p' d sl v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma> \<and> d > 0 \<and> ODEsol ode sl d \<and> sl 0 = \<sigma>\<^sub>p \<and> 
    (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (sl t)) \<and> big_step C ((sl d)(var := v)) l' \<sigma>\<^sub>p'}"
    have "sem C ?S1 = ?R1" "sem C ?S2 = ?R2"
      using sem_interrupt_recv1 apply blast
      using sem_interrupt_recv2[of C var cs ch \<Sigma> ode b] by blast
    with c1 have c2: "Q (?R1 \<union> ?R2)"
      by auto
    from InterruptH3.hyps(5) c0 have "R (sem_interrupt n ode b cs \<Sigma>)"
      by (simp add: interrupt_Valid_def)
    then have "(join R Q) ((sem_interrupt n ode b cs \<Sigma>) \<union> (?R1 \<union> ?R2))"
      using c2 joinI by blast
    with InterruptH3.hyps(3) show "(join R Q) (sem_interrupt (Suc n) ode b cs \<Sigma>)"
      using sem_interrupt_Suc_Recv[of cs n ch var C ode b \<Sigma>]
      by (simp add: sup_assoc)
  qed
next
  case (InterruptH4 P cs ode b Q)
  then show ?case
    by (simp add: hyper_hoare_tripleI interrupt_Valid_def sem_interrupt_final)
next
  case (ExistsH P C Q)
  then show ?case
    by (simp add: rule_exists)
qed

definition complete
  where
  "complete P C Q \<longleftrightarrow> (\<Turnstile> {P} C {Q} \<longrightarrow> \<turnstile> {P} C {Q})"

lemma completeI:
  assumes "\<Turnstile> {P} C {Q} \<Longrightarrow> \<turnstile> {P} C {Q}"
  shows "complete P C Q"
  by (simp add: assms complete_def)

lemma completeE:
  assumes "complete P C Q"
      and "\<Turnstile> {P} C {Q}"
    shows "\<turnstile> {P} C {Q}"
  using assms complete_def by auto

lemma complete_ichoice_aux:
  assumes "hyper_hoare_triple A (IChoice C1 C2) B"
  shows "entails (\<lambda>S'. \<exists>S. A S \<and> S' = sem C1 S \<union> sem C2 S) B"
proof (rule entailsI)
  fix S' assume "\<exists>S. A S \<and> S' = sem C1 S \<union> sem C2 S"
  then show "B S'"
    by (metis assms hyper_hoare_tripleE sem_if)
qed

lemma complete_ichoice:
  fixes P Q :: "('lvar, 'lval) conf set \<Rightarrow> bool"
  assumes "\<And>P1 Q1 :: ('lvar, 'lval) conf set \<Rightarrow> bool. complete P1 C1 Q1"
      and "\<And>P2 Q2 :: ('lvar, 'lval) conf set \<Rightarrow> bool. complete P2 C2 Q2"
    shows "complete P (IChoice C1 C2) Q"
proof (rule completeI)
  assume asm0: "\<Turnstile> {P} IChoice C1 C2 {Q}"
  show "\<turnstile> {P} IChoice C1 C2 {Q}"
  proof (rule ConsH)
    show "\<turnstile> {exists (\<lambda>V S. P S \<and> S = V)} IChoice C1 C2 {exists (\<lambda>V. join (\<lambda>S. S = sem C1 V \<and> P V) (\<lambda>S. S = sem C2 V))}"
    proof (rule ExistsH)
      fix V
      show "\<turnstile> {(\<lambda>S. P S \<and> S = V)} IChoice C1 C2 {join (\<lambda>S. S = sem C1 V \<and> P V) (\<lambda>S. S = sem C2 V)}"
      proof (rule IChoiceH)
        show "\<turnstile> {(\<lambda>S. P S \<and> S = V)} C1 {\<lambda>S. S = sem C1 V \<and> P V}"
          by (simp add: assms(1) completeE hyper_hoare_triple_def)
        show "\<turnstile> {(\<lambda>S. P S \<and> S = V)} C2 {\<lambda>S. S = sem C2 V}"
          by (simp add: assms(2) completeE hyper_hoare_triple_def)
      qed
    qed
    show "entails P (exists (\<lambda>V S. P S \<and> S = V))"
      by (simp add: entailsI exists_def)
    show "entails (exists (\<lambda>V. join (\<lambda>S. S = sem C1 V \<and> P V) (\<lambda>S. S = sem C2 V))) Q"
    proof (rule entailsI)
      fix S assume "exists (\<lambda>V. join (\<lambda>S. S = sem C1 V \<and> P V) (\<lambda>S. S = sem C2 V)) S"
      then obtain V where "join (\<lambda>S. S = sem C1 V \<and> P V) (\<lambda>S. S = sem C2 V) S"
        by (meson exists_def)
      then obtain S1 S2 where "S = S1 \<union> S2" "S1 = sem C1 V \<and> P V" "S2 = sem C2 V"
        by (simp add: join_def)
      then show "Q S"
        by (metis asm0 hyper_hoare_tripleE sem_if)
    qed
  qed
qed

lemma complete_seq_aux:
  assumes "hyper_hoare_triple A (Seq C1 C2) B"
  shows "\<exists>R. hyper_hoare_triple A C1 R \<and> hyper_hoare_triple R C2 B"
proof -
  let ?R = "\<lambda>S. \<exists>S'. A S' \<and> S = sem C1 S'"
  have "hyper_hoare_triple A C1 ?R"
    using hyper_hoare_triple_def by blast
  moreover have "hyper_hoare_triple ?R C2 B"
  proof (rule hyper_hoare_tripleI)
    fix S assume "\<exists>S'. A S' \<and> S = sem C1 S'"
    then obtain S' where asm0: "A S'" "S = sem C1 S'"
      by blast
    then show "B (sem C2 S)"
      by (metis assms hyper_hoare_tripleE sem_seq)
  qed
  ultimately show ?thesis by blast
qed

lemma complete_seq:
  assumes "\<And>R. complete P C1 R"
      and "\<And>R. complete R C2 Q"
    shows "complete P (Seq C1 C2) Q"
  by (meson SeqH assms(1) assms(2) completeE completeI complete_seq_aux)

lemma complete_assume:
  "complete P (Assume b) Q"
proof (rule completeI)
  assume asm0: "\<Turnstile> {P} Assume b {Q}"
  show "\<turnstile> {P} Assume b {Q}"
  proof (rule ConsH)
    show "\<turnstile> {(\<lambda>S. Q (Set.filter (b \<circ> fst \<circ> snd) S))} (Assume b) {Q}"
      by (simp add: AssumeH)
    show "entails P (\<lambda>S. Q (Set.filter (b \<circ> fst \<circ> snd) S))"
      by (metis (mono_tags, lifting) asm0 assume_sem entails_def hyper_hoare_tripleE)
    show "entails Q Q"      
      by (simp add: entailsI)
  qed
qed

lemma complete_skip:
  "complete P Skip Q"
  using completeI SkipH
  by (metis (mono_tags, lifting) entails_def hyper_hoare_triple_def sem_skip ConsH)

lemma complete_assign:
  "complete P (Assign x e) Q"
proof (rule completeI)
  assume asm0: "\<Turnstile> {P} Assign x e {Q}"
  show "\<turnstile> {P} Assign x e {Q}"
  proof (rule ConsH)
    show "\<turnstile> {\<lambda>S. Q {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(x := e \<sigma>\<^sub>p), l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S}} Assign x e {Q}"
      by (simp add: AssignH)
    show "entails P (\<lambda>S. Q {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(x := e \<sigma>\<^sub>p), l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S})"
    proof (rule entailsI)
      fix S assume "P S"
      then show "Q {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(x := e \<sigma>\<^sub>p), l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S}"
        by (metis asm0 hyper_hoare_triple_def sem_assign)
    qed
    show "entails Q Q"
      by (simp add: entailsI)
  qed
qed

lemma complete_havoc:
  "complete P (Havoc x) Q"
proof (rule completeI)
  assume asm0: "\<Turnstile> {P} Havoc x {Q}"
  show "\<turnstile> {P} Havoc x {Q}"
  proof (rule ConsH)
    show "\<turnstile> {\<lambda>S. Q {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(x := v), l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S}} Havoc x {Q}"
      using HavocH by fast
    show "entails P (\<lambda>S. Q {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(x := v), l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S})"
    proof (rule entailsI)
      fix S assume "P S"
      then show "Q {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(x := v), l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S}"
        by (metis asm0 hyper_hoare_triple_def sem_havoc)
    qed
    show "entails Q Q"
      by (simp add: entailsI)
  qed
qed

fun construct_inv
  where
  "construct_inv P C 0 = P"
| "construct_inv P C (Suc n) = (\<lambda>S. (\<exists>S'. S = sem C S' \<and> construct_inv P C n S'))"

lemma iterate_sem_ind:
  assumes "construct_inv P C n S'"
  shows "\<exists>S. P S \<and> S' = iterate_sem n C S"
  using assms
by (induct n arbitrary: S') (auto)

lemma complete_while_aux:
  assumes "hyper_hoare_triple (\<lambda>S. P S \<and> S = V) (Rep C) Q"
  shows "entails (natural_partition (construct_inv (\<lambda>S. P S \<and> S = V) C)) Q"
proof (rule entailsI)
  fix S assume "natural_partition (construct_inv (\<lambda>S. P S \<and> S = V) C) S"

  then obtain F where asm0: "S = (\<Union>n. F n)" "\<And>n. construct_inv (\<lambda>S. P S \<and> S = V) C n (F n)"
    using natural_partitionE by (metis (no_types, lifting))
  then have "P (F 0) \<and> F 0 = V"
    by (metis (mono_tags, lifting) construct_inv.simps(1))
  then have "Q (\<Union>n. iterate_sem n C (F 0))"
    using assms hyper_hoare_triple_def[of "\<lambda>S. P S \<and> S = V" "Rep C" Q] sem_while
    by metis
  moreover have "\<And>n. F n = iterate_sem n C V"
  proof -
    fix n
    obtain S' where "P S' \<and> S' = V" "F n = iterate_sem n C S'"
      using asm0(2) iterate_sem_ind by blast
    then show "F n = iterate_sem n C V"
      by simp
  qed
  ultimately show "Q S"
    using asm0(1) by auto
qed

lemma complete_while:
  fixes P Q :: "('lvar, 'lval) conf set \<Rightarrow> bool"
  assumes "\<And>P' Q' :: ('lvar, 'lval) conf set \<Rightarrow> bool. complete P' C Q'"
    shows "complete P (Rep C) Q"
proof (rule completeI)
  assume asm0: "hyper_hoare_triple P (Rep C) Q"

  let ?I = "\<lambda>V. construct_inv (\<lambda>S. P S \<and> S = V) C"

  have r: "\<And>V. hoare (?I V 0) (Rep C) (natural_partition (?I V))"
  proof (rule RepH)
    fix V n show "hoare (construct_inv (\<lambda>S. P S \<and> S = V) C n) C (construct_inv (\<lambda>S. P S \<and> S = V) C (Suc n))"
      by (meson assms completeE construct_inv.simps(2) hyper_hoare_tripleI)
  qed

  show "hoare P (Rep C) Q"
  proof (rule ConsH)
    show "hoare (exists (\<lambda>V. ?I V 0)) (Rep C) (exists (\<lambda>V. ((natural_partition (?I V)))))"
      using r by (rule ExistsH)
    show "entails P (exists (\<lambda>V. construct_inv (\<lambda>S. P S \<and> S = V) C 0))"
      by (simp add: entailsI exists_def)
    show "entails (exists (\<lambda>V. natural_partition (construct_inv (\<lambda>S. P S \<and> S = V) C))) Q"
    proof (rule entailsI)
      fix S' assume "exists (\<lambda>V. natural_partition (construct_inv (\<lambda>S. P S \<and> S = V) C)) S'"
      then obtain V where "natural_partition (construct_inv (\<lambda>S. P S \<and> S = V) C) S'"
        by (meson exists_def)
      moreover have "entails (natural_partition (construct_inv (\<lambda>S. P S \<and> S = V) C)) Q"
      proof (rule complete_while_aux)
        show "hyper_hoare_triple (\<lambda>S. P S \<and> S = V) (Rep C) Q"
          using asm0 hyper_hoare_triple_def[of "\<lambda>S. P S \<and> S = V"]
          hyper_hoare_triple_def[of P "Rep C" Q] by auto
      qed
      ultimately show "Q S'"
        by (simp add: entails_def)
    qed
  qed
qed

lemma complete_send:
  "complete P (Cm (ch[!]e)) Q"
proof(rule completeI)
  assume assm0: "\<Turnstile> {P} Cm (ch[!]e) {Q}"
  show " \<turnstile> {P} Cm (ch[!]e) {Q}"
  proof (rule ConsH)
    show "\<turnstile> {(\<lambda>S. Q ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [OutBlock ch (e \<sigma>\<^sub>p)]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union> {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, 
    l @ [WaitBlk d (\<lambda>_. State \<sigma>\<^sub>p) ({ch}, {}), OutBlock ch (e \<sigma>\<^sub>p)]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d. (d::real) > 0 \<and> (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union>
    {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [WaitBlk \<infinity> (\<lambda>_. State \<sigma>\<^sub>p) ({ch}, {})]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S}))} (Cm (ch[!]e)) {Q}"
      using SendH by blast
    show "entails P (\<lambda>S. Q ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [OutBlock ch (e \<sigma>\<^sub>p)]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union>
    {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [WaitBlk (ereal d) (\<lambda>_. State \<sigma>\<^sub>p) ({ch}, {}), OutBlock ch (e \<sigma>\<^sub>p)]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d. 0 < d 
    \<and> (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union> {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [WaitBlk \<infinity> (\<lambda>_. State \<sigma>\<^sub>p) ({ch}, {})]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S}))"
    proof (rule entailsI)
      fix S assume "P S"
      then show "Q ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [OutBlock ch (e \<sigma>\<^sub>p)]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union>  {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, 
      l @ [WaitBlk (ereal d) (\<lambda>_. State \<sigma>\<^sub>p) ({ch}, {}), OutBlock ch (e \<sigma>\<^sub>p)]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d. 0 < d \<and> (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union>
      {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [WaitBlk \<infinity> (\<lambda>_. State \<sigma>\<^sub>p) ({ch}, {})]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S})"
        by (metis assm0 hyper_hoare_triple_def sem_send)
    qed
    show "entails Q Q"
      by (simp add: entailsI)
  qed
qed

lemma complete_recv:
  "complete P (Cm (ch[?]var)) Q"
proof(rule completeI)
  assume assm0: "\<Turnstile> {P} Cm (ch[?]var) {Q}"
  show " \<turnstile> {P} Cm (ch[?]var) {Q}"
  proof (rule ConsH)
    show "\<turnstile> {(\<lambda>S. Q ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p(var := v), l @ [InBlock ch v]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union>
  {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(var := v), l @ [WaitBlk d (\<lambda>_. State \<sigma>\<^sub>p) ({}, {ch}), InBlock ch v]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d v. (d::real) > 0 
  \<and> (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union> {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [WaitBlk \<infinity> (\<lambda>_. State \<sigma>\<^sub>p) ({}, {ch})]) 
  |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S}))} (Cm (ch[?]var)) {Q}"
      using RecvH by blast
    show "entails P (\<lambda>S. Q ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p(var := v), l @ [InBlock ch v]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union>
    {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(var := v), l @ [WaitBlk (ereal d) (\<lambda>_. State \<sigma>\<^sub>p) ({}, {ch}), InBlock ch v]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d v.
    0 < d \<and> (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union> {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [WaitBlk \<infinity> (\<lambda>_. State \<sigma>\<^sub>p) ({}, {ch})]) 
    |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S}))"
    proof (rule entailsI)
      fix S assume "P S"
      then show "Q ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p(var := v), l @ [InBlock ch v]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union>
      {(\<sigma>\<^sub>l, \<sigma>\<^sub>p(var := v), l @ [WaitBlk (ereal d) (\<lambda>_. State \<sigma>\<^sub>p) ({}, {ch}), InBlock ch v]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d v.
      0 < d \<and> (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S} \<union> {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [WaitBlk \<infinity> (\<lambda>_. State \<sigma>\<^sub>p) ({}, {ch})]) 
      |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S})"
        by (metis assm0 hyper_hoare_triple_def sem_recv)
    qed
    show "entails Q Q"
      by (simp add: entailsI)
  qed
qed

lemma complete_cont:
  "complete P (Cont ode b) Q"
proof(rule completeI)
  assume assm0: "\<Turnstile> {P} (Cont ode b) {Q}"
  show " \<turnstile> {P} (Cont ode b) {Q}"
  proof (rule ConsH)
    show "\<turnstile> {(\<lambda>S. Q ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S \<and> \<not> b \<sigma>\<^sub>p} \<union> {(\<sigma>\<^sub>l, p d, 
    l @ [WaitBlk d (\<lambda>\<tau>. State (p \<tau>)) ({}, {})]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l p d. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S \<and> d > 0 \<and> 
    ODEsol ode p d \<and> (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (p t)) \<and> \<not>b (p d) \<and> p 0 = \<sigma>\<^sub>p}))} (Cont ode b) {Q}"
      using ContH by blast
    show "entails P (\<lambda>S. Q ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S \<and> \<not> b \<sigma>\<^sub>p} \<union> {(\<sigma>\<^sub>l, p d, 
    l @ [WaitBlk d (\<lambda>\<tau>. State (p \<tau>)) ({}, {})]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l p d. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S \<and> d > 0 \<and> 
    ODEsol ode p d \<and> (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (p t)) \<and> \<not>b (p d) \<and> p 0 = \<sigma>\<^sub>p}))"
    proof (rule entailsI)
      fix S assume "P S"
      then show "Q ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S \<and> \<not> b \<sigma>\<^sub>p} \<union> {(\<sigma>\<^sub>l, p d, 
      l @ [WaitBlk d (\<lambda>\<tau>. State (p \<tau>)) ({}, {})]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l p d. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S \<and> d > 0 \<and> 
      ODEsol ode p d \<and> (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (p t)) \<and> \<not>b (p d) \<and> p 0 = \<sigma>\<^sub>p})"
        by (metis assm0 hyper_hoare_triple_def sem_ode)
    qed
    show "entails Q Q"
      by (simp add: entailsI)
  qed
qed

lemma complete_int_aux:
  assumes "\<forall>e \<in> set es. \<turnstile> {wp (snd e) R} (snd e) {R}"
  shows "n \<le> length es \<Longrightarrow> interrupt_hoare 
  (\<lambda>\<Sigma>. (\<forall>i < n. 
    case es ! i of
      (ch[!]e, p2) \<Rightarrow> (wp p2 R) ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [OutBlock ch (e \<sigma>\<^sub>p)]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>} \<union>
      {(\<sigma>\<^sub>l, sl d, l @ [WaitBlk (ereal d) (\<lambda>\<tau>. State (sl \<tau>)) (rdy_of_echoice cs), OutBlock ch (e (sl d))]) 
      |\<sigma>\<^sub>l \<sigma>\<^sub>p l d sl. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma> \<and> 0 < d \<and> ODEsol ode sl d \<and> sl 0 = \<sigma>\<^sub>p \<and> (\<forall>t. 0 \<le> t \<and> t < d \<longrightarrow> b (sl t))})
    | (ch[?]var, p2) \<Rightarrow> (wp p2 R) ({(\<sigma>\<^sub>l, \<sigma>\<^sub>p(var := v), l @ [InBlock ch v]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma>} \<union> 
      {(\<sigma>\<^sub>l, (sl d)(var := v), l @ [WaitBlk (ereal d) (\<lambda>\<tau>. State (sl \<tau>)) (rdy_of_echoice cs), InBlock ch v]) 
      |\<sigma>\<^sub>l \<sigma>\<^sub>p l d sl v. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> \<Sigma> \<and> 0 < d \<and> ODEsol ode sl d \<and> sl 0 = \<sigma>\<^sub>p \<and> 
      (\<forall>t. 0 \<le> t \<and> t < d \<longrightarrow> b (sl t))})))
  n ode b es R"
proof (induction n)
  case 0
  show ?case
sorry
(*
proof(induct "length cs" arbitrary: Q cs)
  case 0
  let ?Q = "(exists (\<lambda>S0. \<lambda>S. P S0 \<and> (\<exists>S1 S2. S1 = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> \<not> b \<sigma>\<^sub>p} \<and>
    S2 = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p', l @ [WaitBlk d (\<lambda> \<tau>. State (sl \<tau>)) (rdy_of_echoice [])]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d sl \<sigma>\<^sub>p'. 
    (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> d > 0 \<and> ODEsol ode sl d \<and> (\<forall>t. t \<ge> 0 \<and> t < d \<longrightarrow> b (sl t)) \<and> \<not> b (sl d) 
    \<and> sl 0 = \<sigma>\<^sub>p \<and> sl d = \<sigma>\<^sub>p'} \<and> S = S1 \<union> S2)))"
  have asm1: "entails ?Q Q"
    using "0.hyps" "0.prems" rule_complete_int_Nil[of P ode b Q] by auto
  have "interrupt_hoare P (length []) ode b [] ?Q"
    using InterruptH1[of P ode b Nil] by simp
  with asm1 "0.hyps" show ?case
    by auto
next
  case (Suc n)
  then obtain a cs' where asm0: "cs = cs' @ [a]"
    by (metis length_Suc_conv_rev)
  show ?case
  proof(cases "fst a")
    case (Send ch e)
    with Suc.prems(2) asm0 obtain Q' R where asm1:
    "entails (join Q' R) Q" "\<Turnstile> {P} Interrupt ode b cs' {R}" 
    "\<Turnstile> {exists (\<lambda>S0. \<lambda>S. P S0 \<and> (\<exists>S1 S2. S1 = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [OutBlock ch (e \<sigma>\<^sub>p)])|\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0} 
     \<and> S2 = {(\<sigma>\<^sub>l, sl d, l @ [WaitBlk d (\<lambda>\<tau>. State (sl \<tau>)) (rdy_of_echoice cs'), OutBlock ch (e (sl d))]) 
     |\<sigma>\<^sub>l \<sigma>\<^sub>p l d sl. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> d > 0 \<and> ODEsol ode sl d \<and> sl 0 = \<sigma>\<^sub>p \<and> (\<forall>t. t \<ge> 0 \<and> t < d 
     \<longrightarrow> b (sl t))} \<and> S = S1 \<union> S2))} snd a {Q'}"
      using rule_comlete_int_send[of P ode b cs' a Q ch e "snd a"]
      by (metis (no_types, lifting) split_pairs)
    with asm0 Suc.prems(1) have " \<turnstile> {exists (\<lambda>S0. \<lambda>S. P S0 \<and> (\<exists>S1 S2. S1 = {(\<sigma>\<^sub>l, \<sigma>\<^sub>p, l @ [OutBlock ch (e \<sigma>\<^sub>p)])
    |\<sigma>\<^sub>l \<sigma>\<^sub>p l. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0} \<and> S2 = {(\<sigma>\<^sub>l, sl d, l @ [WaitBlk d (\<lambda>\<tau>. State (sl \<tau>)) (rdy_of_echoice cs'), 
    OutBlock ch (e (sl d))]) |\<sigma>\<^sub>l \<sigma>\<^sub>p l d sl. (\<sigma>\<^sub>l, \<sigma>\<^sub>p, l) \<in> S0 \<and> d > 0 \<and> ODEsol ode sl d \<and> sl 0 = \<sigma>\<^sub>p \<and>
     (\<forall>t. t \<ge> 0 \<and> t < d  \<longrightarrow> b (sl t))} \<and> S = S1 \<union> S2))} snd a {Q'}"
    from asm1(2) Suc.hyps(1)[of cs'] assms(1)
    then show ?thesis sorry
  next
    case (Receive x21 x22)
    then show ?thesis sorry
  qed
qed
*)


lemma complete_int:
  assumes "\<And>a P Q. a \<in> set cs \<Longrightarrow>  \<Turnstile> {P} snd a {Q} \<Longrightarrow> \<turnstile> {P} snd a {Q}"
      and "\<Turnstile> {P} Interrupt ode b cs {Q}"
    shows "\<turnstile> {P} Interrupt ode b cs {Q}"
  sorry
(*
proof-
  from assms obtain Q' where asm0: "interrupt_hoare P (length cs) ode b cs Q'" "entails Q' Q"
    using complete_int_aux by blast
  show "\<turnstile> {P} Interrupt ode b cs {Q}"
  proof(rule ConsH)
    show "\<turnstile> {P} Interrupt ode b cs {Q'}"
      using InterruptH4 asm0(1) by blast
    show "entails P P"
      by (simp add: entails_refl)
    show "entails Q' Q"
      by (simp add: asm0(2))
  qed
qed
*)
theorem completeness:
  fixes P Q :: "('lvar, 'lval) conf set \<Rightarrow> bool"
  assumes "\<Turnstile> {P} C {Q}"
  shows "\<turnstile> {P} C {Q}"
  using assms
proof (induct C arbitrary: P Q)
  case (Cm x)
  then show ?case
    by (metis Logic.completeE comm.exhaust complete_recv complete_send)
next
  case Skip
  then show ?case
    by (simp add: Logic.completeE complete_skip)
next
  case (Assign x1a x2)
  then show ?case
    by (simp add: Logic.completeE complete_assign)
next
  case (Havoc x)
  then show ?case
    by (simp add: Logic.completeE complete_havoc)
next
  case (Seq C1 C2)
  then show ?case
    by (meson SeqH complete_seq_aux)
next
  case (Assume x)
  then show ?case
    by (simp add: Logic.completeE complete_assume)
next
  case (IChoice C1 C2)
  then show ?case
    by (meson Logic.completeE Logic.completeI complete_ichoice)
next
  case (Rep C)
  then show ?case
    by (meson Logic.completeE Logic.completeI complete_while)
next
  case (Cont x1a x2)
  then show ?case
    by (simp add: Logic.completeE complete_cont)
next
  case (Interrupt ode b cs)
  then show ?case
    by (meson complete_int snds.simps)
qed


subsection \<open>Validity for parallel programs\<close>

subsection \<open>Basic elimination rules\<close>

named_theorems sync_elims

lemma combine_blocks_pairE [sync_elims]:
  "combine_blocks comms (CommBlock ch_type1 ch1 v1 # tr1) (CommBlock ch_type2 ch2 v2 # tr2) tr \<Longrightarrow>
   ch1 \<in> comms \<Longrightarrow> ch2 \<in> comms \<Longrightarrow>
   (\<And>tr'. ch1 = ch2 \<Longrightarrow> v1 = v2 \<Longrightarrow> (ch_type1 = In \<and> ch_type2 = Out \<or> ch_type1 = Out \<and> ch_type2 = In) \<Longrightarrow>
   tr = IOBlock ch1 v1 # tr' \<Longrightarrow> combine_blocks comms tr1 tr2 tr' \<Longrightarrow> P) \<Longrightarrow> P"
  by (induct rule: combine_blocks.cases, auto)

lemma combine_blocks_unpairE1 [sync_elims]:
  "combine_blocks comms (CommBlock ch_type1 ch1 v1 # tr1) (CommBlock ch_type2 ch2 v2 # tr2) tr \<Longrightarrow>
   ch1 \<notin> comms \<Longrightarrow> ch2 \<in> comms \<Longrightarrow>
   (\<And>tr'. tr = CommBlock ch_type1 ch1 v1 # tr' \<Longrightarrow>
           combine_blocks comms tr1 (CommBlock ch_type2 ch2 v2 # tr2) tr' \<Longrightarrow> P) \<Longrightarrow> P"
  by (induct rule: combine_blocks.cases, auto)

lemma combine_blocks_unpairE1' [sync_elims]:
  "combine_blocks comms (CommBlock ch_type1 ch1 v1 # tr1) (CommBlock ch_type2 ch2 v2 # tr2) tr \<Longrightarrow>
   ch1 \<in> comms \<Longrightarrow> ch2 \<notin> comms \<Longrightarrow>
   (\<And>tr'. tr = CommBlock ch_type2 ch2 v2 # tr' \<Longrightarrow>
           combine_blocks comms (CommBlock ch_type1 ch1 v1 # tr1) tr2 tr' \<Longrightarrow> P) \<Longrightarrow> P"
  by (induct rule: combine_blocks.cases, auto)

lemma combine_blocks_unpairE2 [sync_elims]:
  "combine_blocks comms (CommBlock ch_type1 ch1 v1 # tr1) (CommBlock ch_type2 ch2 v2 # tr2) tr \<Longrightarrow>
   ch1 \<notin> comms \<Longrightarrow> ch2 \<notin> comms \<Longrightarrow>
   (\<And>tr'. tr = CommBlock ch_type1 ch1 v1 # tr' \<Longrightarrow>
           combine_blocks comms tr1 (CommBlock ch_type2 ch2 v2 # tr2) tr' \<Longrightarrow> P) \<Longrightarrow>
   (\<And>tr'. tr = CommBlock ch_type2 ch2 v2 # tr' \<Longrightarrow>
           combine_blocks comms (CommBlock ch_type1 ch1 v1 # tr1) tr2 tr' \<Longrightarrow> P) \<Longrightarrow> P"
  by (induct rule: combine_blocks.cases, auto)

lemma combine_blocks_pairE2 [sync_elims]:
  "combine_blocks comms (CommBlock ch_type1 ch1 v1 # tr1) (WaitBlk d2 p2 rdy2 # tr2) tr \<Longrightarrow>
   ch1 \<in> comms \<Longrightarrow> P"
  by (induct rule: combine_blocks.cases, auto)

lemma combine_blocks_pairE2' [sync_elims]:
  "combine_blocks comms (WaitBlk d1 p1 rdy1 # tr1) (CommBlock ch_type2 ch2 v2 # tr2) tr \<Longrightarrow>
   ch2 \<in> comms \<Longrightarrow> P"
  by (induct rule: combine_blocks.cases, auto)

lemma combine_blocks_unpairE3 [sync_elims]:
  "combine_blocks comms (CommBlock ch_type1 ch1 v1 # tr1) (WaitBlk d2 p2 rdy2 # tr2) tr \<Longrightarrow>
   ch1 \<notin> comms \<Longrightarrow>
   (\<And>tr'. tr = CommBlock ch_type1 ch1 v1 # tr' \<Longrightarrow>
           combine_blocks comms tr1 (WaitBlk d2 p2 rdy2 # tr2) tr' \<Longrightarrow> P) \<Longrightarrow> P"
  by (induct rule: combine_blocks.cases, auto)

lemma combine_blocks_unpairE3' [sync_elims]:
  "combine_blocks comms (WaitBlk d1 p1 rdy1 # tr1) (CommBlock ch_type2 ch2 v2 # tr2) tr \<Longrightarrow>
   ch2 \<notin> comms \<Longrightarrow>
   (\<And>tr'. tr = CommBlock ch_type2 ch2 v2 # tr' \<Longrightarrow>
           combine_blocks comms (WaitBlk d1 p1 rdy1 # tr1) tr2 tr' \<Longrightarrow> P) \<Longrightarrow> P"
  by (induct rule: combine_blocks.cases, auto)

lemma combine_blocks_waitE1 [sync_elims]:
  "combine_blocks comms (WaitBlk d1 p1 rdy1 # tr1) (WaitBlk d2 p2 rdy2 # tr2) tr \<Longrightarrow>
   \<not>compat_rdy rdy1 rdy2 \<Longrightarrow> P"
proof (induct rule: combine_blocks.cases)
  case (combine_blocks_wait1 comms blks1 blks2 blks rdy1 rdy2 hist hist1 hist2 rdy t)
  then show ?case
    by (metis WaitBlk_cong list.inject)
next
  case (combine_blocks_wait2 comms blks1 t2 t1 hist2 rdy2 blks2 blks rdy1 hist hist1 rdy)
  then show ?case 
    by (metis WaitBlk_cong list.inject)
next
  case (combine_blocks_wait3 comms t1 t2 hist1 rdy1 blks1 blks2 blks rdy2 hist hist2 rdy)
  then show ?case 
    by (metis WaitBlk_cong list.inject)
qed (auto)

lemma combine_blocks_waitE2 [sync_elims]:
  "combine_blocks comms (WaitBlk d p1 rdy1 # tr1) (WaitBlk d p2 rdy2 # tr2) tr \<Longrightarrow>
   compat_rdy rdy1 rdy2 \<Longrightarrow>
   (\<And>tr'. tr = WaitBlk d (\<lambda>t. ParState (p1 t) (p2 t)) (merge_rdy rdy1 rdy2) # tr' \<Longrightarrow>
           combine_blocks comms tr1 tr2 tr' \<Longrightarrow> P) \<Longrightarrow> P"
proof (induct rule: combine_blocks.cases)
  case (combine_blocks_wait1 comms' blks1 blks2 blks rdy1' rdy2' hist hist1 hist2 rdy t)
  have a: "d = t" "rdy1 = rdy1'" "rdy2 = rdy2'" "tr1 = blks1" "tr2 = blks2" 
    using combine_blocks_wait1(2,3) by (auto simp add: WaitBlk_cong)
  have b: "WaitBlk d (\<lambda>t. ParState (p1 t) (p2 t)) (merge_rdy rdy1 rdy2) =
           WaitBlk t (\<lambda>t. ParState (hist1 t) (hist2 t)) (merge_rdy rdy1' rdy2')"
    apply (rule WaitBlk_eq_combine) using combine_blocks_wait1(2,3) by auto 
  show ?case
    apply (rule combine_blocks_wait1)
    unfolding b using combine_blocks_wait1(4) unfolding a combine_blocks_wait1(7,8)
    by (auto simp add: combine_blocks_wait1(1,5))
next
  case (combine_blocks_wait2 comms blks1 t2 t1 hist2 rdy2 blks2 blks rdy1 hist hist1 rdy)
  have a: "d = ereal t1" "d = t2"
    using combine_blocks_wait2(2,3) by (auto simp add: WaitBlk_cong)
  show ?case
    using a combine_blocks_wait2(7) by auto
next
  case (combine_blocks_wait3 comms t1 t2 hist1 rdy1 blks1 blks2 blks rdy2 hist hist2 rdy)
  have a: "d = ereal t2" "d = t1"
    using combine_blocks_wait3(2,3) by (auto simp add: WaitBlk_cong)
  show ?case
    using a combine_blocks_wait3(7) by auto
qed (auto)

lemma combine_blocks_waitE3 [sync_elims]:
  "combine_blocks comms (WaitBlk d1 p1 rdy1 # tr1) (WaitBlk d2 p2 rdy2 # tr2) tr \<Longrightarrow>
   0 < d1 \<Longrightarrow> d1 < d2 \<Longrightarrow>
   compat_rdy rdy1 rdy2 \<Longrightarrow>
   (\<And>tr'. tr = WaitBlk d1 (\<lambda>t. ParState (p1 t) (p2 t)) (merge_rdy rdy1 rdy2) # tr' \<Longrightarrow>
           combine_blocks comms tr1 (WaitBlk (d2 - d1) (\<lambda>t. p2 (t + d1)) rdy2 # tr2) tr' \<Longrightarrow> P) \<Longrightarrow> P"
proof (induct rule: combine_blocks.cases)
  case (combine_blocks_wait1 comms blks1 blks2 blks rdy1 rdy2 hist hist1 hist2 rdy t)
  have a: "t = ereal d1" "t = d2"
    using combine_blocks_wait1(2,3) WaitBlk_cong by blast+
  then show ?case
    using combine_blocks_wait1(10) by auto
next
  case (combine_blocks_wait2 comms' blks1 t2 t1 hist2 rdy2' blks2 blks rdy1' hist hist1 rdy)
  have a: "d1 = t1" "d2 = t2" "rdy1 = rdy1'" "rdy2 = rdy2'" "tr1 = blks1" "tr2 = blks2" 
    using combine_blocks_wait2(2,3) using WaitBlk_cong by blast+
  have a2: "WaitBlk d2 p2 rdy2 = WaitBlk d2 hist2 rdy2"
    using combine_blocks_wait2(3) unfolding a[symmetric] by auto
  have a3: "WaitBlk d1 p2 rdy2 = WaitBlk d1 hist2 rdy2"
           "WaitBlk (d2 - d1) (\<lambda>\<tau>. p2 (\<tau> + d1)) rdy2 = WaitBlk (d2 - d1) (\<lambda>\<tau>. hist2 (\<tau> + d1)) rdy2"
    using WaitBlk_split[OF a2] combine_blocks_wait2 by auto
  have b: "WaitBlk d1 (\<lambda>t. ParState (p1 t) (p2 t)) (merge_rdy rdy1 rdy2) =
           WaitBlk t1 (\<lambda>t. ParState (hist1 t) (hist2 t)) (merge_rdy rdy1' rdy2')"
    apply (rule WaitBlk_eq_combine)
    using combine_blocks_wait2.hyps(2) a(1,4) a3 by auto
  show ?case
    apply (rule combine_blocks_wait2) unfolding a3 b
    using combine_blocks_wait2(4) unfolding combine_blocks_wait2(9,10)
    by (auto simp add: a combine_blocks_wait2(1,5))
next
  case (combine_blocks_wait3 comms t1 t2 hist1 rdy1 blks1 blks2 blks rdy2 hist hist2 rdy)
  have "ereal d1 = t1" "d2 = ereal t2"
    using combine_blocks_wait3(2,3) by (auto simp add: WaitBlk_cong)
  then show ?case
    using combine_blocks_wait3(7,12) by auto
qed (auto)

lemma combine_blocks_waitE4 [sync_elims]:
  "combine_blocks comms (WaitBlk d1 p1 rdy1 # tr1) (WaitBlk d2 p2 rdy2 # tr2) tr \<Longrightarrow>
   0 < d2 \<Longrightarrow> d2 < d1 \<Longrightarrow>
   compat_rdy rdy1 rdy2 \<Longrightarrow>
   (\<And>tr'. tr = WaitBlk d2 (\<lambda>t. ParState (p1 t) (p2 t)) (merge_rdy rdy1 rdy2) # tr' \<Longrightarrow>
           combine_blocks comms (WaitBlk (d1 - d2) (\<lambda>t. p1 (t + d2)) rdy1 # tr1) tr2 tr' \<Longrightarrow> P) \<Longrightarrow> P"
proof (induct rule: combine_blocks.cases)
  case (combine_blocks_wait1 comms blks1 blks2 blks rdy1 rdy2 hist hist1 hist2 rdy t)
  have "d1 = t" "ereal d2 = t"
    using combine_blocks_wait1(2,3) by (auto simp add: WaitBlk_cong)
  then show ?case
    using combine_blocks_wait1(10) by auto
next
  case (combine_blocks_wait2 comms blks1 t2 t1 hist2 rdy2 blks2 blks rdy1 hist hist1 rdy)
  have "d1 = ereal t1" "ereal d2 = t2"
    using combine_blocks_wait2(2,3) by (auto simp add: WaitBlk_cong)
  then show ?case
    using combine_blocks_wait2(7,12) by auto
next
  case (combine_blocks_wait3 comms t1 t2 hist1 rdy1' blks1 blks2 blks rdy2' hist hist2 rdy)
  have a: "d1 = t1" "d2 = t2" "rdy1 = rdy1'" "rdy2 = rdy2'"
          "tr1 = blks1" "tr2 = blks2" 
    using combine_blocks_wait3(2,3) using WaitBlk_cong by blast+
  have a2: "WaitBlk d1 p1 rdy1 = WaitBlk d1 hist1 rdy1"
    using combine_blocks_wait3(2) unfolding a[symmetric] by auto
  have a3: "WaitBlk d2 p1 rdy1 = WaitBlk d2 hist1 rdy1"
           "WaitBlk (d1 - d2) (\<lambda>\<tau>. p1 (\<tau> + d2)) rdy1 = WaitBlk (d1 - d2) (\<lambda>\<tau>. hist1 (\<tau> + d2)) rdy1"
    using WaitBlk_split[OF a2] combine_blocks_wait3 by auto
  have b: "WaitBlk d2 (\<lambda>t. ParState (p1 t) (p2 t)) (merge_rdy rdy1 rdy2) =
           WaitBlk d2 (\<lambda>t. ParState (hist1 t) (hist2 t)) (merge_rdy rdy1' rdy2')"
    apply (rule WaitBlk_eq_combine)
    using combine_blocks_wait3 a(2,3) a3 by auto
  show ?case
    apply (rule combine_blocks_wait3) unfolding a3 b
    using combine_blocks_wait3(4) unfolding combine_blocks_wait3(9,10)
    by (auto simp add: a combine_blocks_wait3)
qed (auto)

lemma combine_blocks_emptyE1 [sync_elims]:
  "combine_blocks comms [] [] tr \<Longrightarrow> tr = []"
  by (induct rule: combine_blocks.cases, auto)

lemma combine_blocks_emptyE2 [sync_elims]:
  "combine_blocks comms (WaitBlk d1 p1 rdy1 # tr1) [] tr \<Longrightarrow> P"
  by (induct rule: combine_blocks.cases, auto)

lemma combine_blocks_emptyE2' [sync_elims]:
  "combine_blocks comms [] (WaitBlk d2 p2 rdy2 # tr2) tr \<Longrightarrow> P"
  by (induct rule: combine_blocks.cases, auto)

lemma combine_blocks_emptyE3 [sync_elims]:
  "combine_blocks comms (CommBlock ch_type1 ch1 v1 # tr1) [] tr \<Longrightarrow>
   (\<And>tr'. ch1 \<notin> comms \<Longrightarrow> tr = CommBlock ch_type1 ch1 v1 # tr' \<Longrightarrow>
           combine_blocks comms tr1 [] tr' \<Longrightarrow> P) \<Longrightarrow> P"
  by (induct rule: combine_blocks.cases, auto)

lemma combine_blocks_emptyE3' [sync_elims]:
  "combine_blocks comms [] (CommBlock ch_type2 ch2 v2 # tr2) tr \<Longrightarrow>
   (\<And>tr'. ch2 \<notin> comms \<Longrightarrow> tr = CommBlock ch_type2 ch2 v2 # tr' \<Longrightarrow>
           combine_blocks comms [] tr2 tr' \<Longrightarrow> P) \<Longrightarrow> P"
  by (induct rule: combine_blocks.cases, auto)

definition par_hyper_hoare_triple ("\<Turnstile>\<^sub>P {_} _ {_}" [51,0,0] 81) where
  "\<Turnstile>\<^sub>P {P} C {Q} \<longleftrightarrow> (\<forall>S. P S \<longrightarrow> Q (par_sem C S))"

definition emp_trace_assn :: "(state set \<Rightarrow> bool) \<Rightarrow> assn"
  where "emp_trace_assn P \<Sigma> \<longleftrightarrow> P {fst \<phi> |\<phi>. \<phi> \<in> \<Sigma>} \<and> (\<forall>\<phi>. \<phi> \<in> \<Sigma> \<longrightarrow> snd \<phi> = [])"

definition par_single_state_gassn :: "(state set \<Rightarrow> bool) \<Rightarrow> gstate set \<Rightarrow> bool"
  where "par_single_state_gassn P S \<longleftrightarrow> P {\<sigma>. State \<sigma> \<in> S}"

definition par_single_gassn :: "assn \<Rightarrow> (gstate \<times> trace) set \<Rightarrow> bool"
  where "par_single_gassn Q S = Q {(\<sigma>, l) | \<sigma> l. (State \<sigma>, l) \<in> S}"

definition par_state_gassn :: "(gstate set \<Rightarrow> bool) \<Rightarrow> (gstate set \<Rightarrow> bool) \<Rightarrow> gstate set \<Rightarrow> bool"
  where "par_state_gassn P1 P2 S \<longleftrightarrow> P1 {s1. \<exists>s2. (ParState s1 s2) \<in> S} \<and> P2 {s2. \<exists>s1. (ParState s1 s2) \<in> S}"

lemma par_hyper_hoare_tripleI:
  assumes "\<And>S. P S \<Longrightarrow> Q (par_sem C S)"
  shows "\<Turnstile>\<^sub>P {P} C {Q}"
  by (simp add: assms par_hyper_hoare_triple_def)

lemma par_hyper_hoare_tripleE:
  assumes "\<Turnstile>\<^sub>P {P} C {Q}"
      and "P S"
    shows "Q (par_sem C S)"
  using assms(1) assms(2) par_hyper_hoare_triple_def
  by metis

lemma par_consequence_rule:
  assumes "entails P P'"
      and "entails Q' Q"
      and "\<Turnstile>\<^sub>P {P'} C {Q'}"
    shows "\<Turnstile>\<^sub>P {P} C {Q}"
  by (metis (no_types, opaque_lifting) assms(1) assms(2) assms(3) entails_def par_hyper_hoare_triple_def)

(*
lemma rule_par_single:
  assumes "\<Turnstile> {emp_trace_assn P} C {Q}"
  shows "\<Turnstile>\<^sub>P {par_single_state_gassn P} (Single C) {par_single_gassn Q}"
proof(rule par_hyper_hoare_tripleI)
  fix S
  let ?\<Sigma> = "{(\<sigma>, []) |\<sigma>. State \<sigma> \<in> S}"
  assume "par_single_state_gassn P S"
  then have "P {\<sigma>. State \<sigma> \<in> S}"
    using par_single_state_gassn_def by auto
  then have "emp_trace_assn P ?\<Sigma>"
    using emp_trace_assn_def by auto
  then have "Q (sem C ?\<Sigma>)"
    using assms hyper_hoare_tripleE by blast
  then have "Q {(\<sigma>', l @ l') | \<sigma> \<sigma>' l l'. (\<sigma>, l) \<in> ?\<Sigma> \<and> big_step C \<sigma> l' \<sigma>'}"
    using sem_def by auto
  then have "Q {(\<sigma>', l) | \<sigma> \<sigma>' l. State \<sigma> \<in> S \<and> big_step C \<sigma> l \<sigma>'}"
    by auto
  then show "par_single_gassn Q (par_sem (Single C) S)"
    by (smt (verit, del_insts) Collect_cong Pair_inject gstate.inject(1) mem_Collect_eq 
        par_sem_single par_single_gassn_def)
qed
*)

(*
lemma rule_par_Parallel:
  assumes "\<Turnstile>\<^sub>P {P1} C1 {Q1}"
      and "\<Turnstile>\<^sub>P {P2} C2 {Q2}"
    shows "True"
*)

end
